<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>..//GENFIRE/fileio</title>
  <meta name="description" content="GENFIRE Documentation">
  <meta name="author" content="Alan (AJ) Pryor, Jr.">  <link rel="stylesheet" href="css/styles.css?v=1.0">
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
<code>"""<br>* GENFIRE.fileio *<br><br>The primary file input/output module for GENFIRE.<br><br><br>Author: Alan (AJ) Pryor, Jr.<br>Jianwei (John) Miao Coherent Imaging Group<br>University of California, Los Angeles<br>Copyright 2015-2016. All rights reserved.<br>"""<br><br><font color="orange">import </font>numpy as np<br><br><font color="orange">def </font>readVolume(filename, order="C"):<br>    """<br>    * readVolume *<br><br>    Load volume into a numpy array<br><br>    :param filename: filename of volume<br>    :param order: "C" for row-major order (C-style), "F" for column-major (Fortran style)<br>    :return:<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright 2015-2016. All rights reserved.<br><br>    """<br>    <font color="orange">import </font>os<br>    base, ext = os.path.splitext(filename)<br>    <font color="orange">if </font>(ext == ".mrc"):<br>        return readMRC(filename, order=order)<br>    <font color="orange">el<font color="orange">if </font></font>(ext == ".mat"):<br>        return readMAT_volume(filename)<br>    <font color="orange">el<font color="orange">if </font></font>(ext == ".npy"):<br>        return np.load(filename)<br><br><font color="orange">def </font>readMAT_volume(filename):<br><br>    #wrapper around scipy's loadmat<br><br>    <font color="orange">import </font>numpy as np<br>    <font color="orange">import </font>scipy.io<br>    data = scipy.io.loadmat(filename)<br>    var_name = [key <font color="orange">for </font>key in data <font color="orange">if </font>not key.startswith("__")]<br>    <font color="orange">if </font>len(var_name) > 1:<br>        raise IOError("Only 1 variable allowed per .MAT file")<br>    else:<br>        return np.array(data[var_name[0]])<br><br><font color="orange">def </font>readNPY(filename, dtype=float, order="C"):<br>    <font color="orange">import </font>numpy as np<br>    return np.load(filename)<br><br><font color="orange">def </font>readMRC(filename, dtype=float, order="C"):<br>    """<br>    * readMRC *<br><br>    Read in a volume in .mrc file format. See http://bio3d.colorado.edu/imod/doc/mrc_format.txt<br><br>    :param filename: Filename of .mrc<br>    :return: NumPy array containing the .mrc data<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright 2015-2016. All rights reserved.<br><br>    """<br>    <font color="orange">import </font>numpy as np<br>    <font color="orange">import </font>struct<br>    headerIntNumber = 56<br>    sizeof_int = 4<br>    headerCharNumber = 800<br>    sizeof_char = 1<br>    <font color="orange">with </font>open(filename,'rb') as fid:<br>        int_header = struct.unpack('=' + 'i'*headerIntNumber, fid.read(headerIntNumber * sizeof_int))<br>        char_header = struct.unpack('=' + 'c'*headerCharNumber, fid.read(headerCharNumber * sizeof_char))<br>        dimx, dimy, dimz, data_flag= int_header[:4]<br>        <font color="orange">if </font>(data_flag == 0):<br>            datatype='u1'<br>        <font color="orange">el<font color="orange">if </font></font>(data_flag ==1):<br>            datatype='i1'<br>        <font color="orange">el<font color="orange">if </font></font>(data_flag ==2):<br>            datatype='f4'<br>        <font color="orange">el<font color="orange">if </font></font>(data_flag ==3):<br>            datatype='c'<br>        <font color="orange">el<font color="orange">if </font></font>(data_flag ==4):<br>            datatype='f4'<br>        <font color="orange">el<font color="orange">if </font></font>(data_flag ==6):<br>            datatype='u2'<br>        else:<br>            raise ValueError("No supported datatype found!\n")<br><br>        return np.fromfile(file=fid, dtype=datatype,count=dimx*dimy*dimz).reshape((dimx,dimy,dimz),order=order).astype(dtype)<br><br><font color="orange">def </font>writeMRC(filename, arr, datatype='f4', order="C"):<br>    """<br>    * writeMRC *<br><br>    Write a volume to .mrc file format. See http://bio3d.colorado.edu/imod/doc/mrc_format.txt<br>    This version is bare-bones and doesn't write out the full header -- just the critical bits and the<br>    volume itself<br><br>    :param filename: Filename of .mrc file to write<br>    :param arr: NumPy volume of data to write<br>    :param dtype: Type of data to write<br><br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright 2015-2016. All rights reserved<br>    """<br>    <font color="orange">import </font>numpy as np<br><br>    dimx, dimy, dimz = np.shape(arr)<br><br>    <font color="orange">if </font>datatype != arr.dtype:<br>        arr = arr.astype(datatype)<br>    int_header = np.zeros(56,dtype='int32') #must be 4-byte ints<br><br>    <font color="orange">if </font>(datatype == 'u1'):<br>        data_flag = 0<br>    <font color="orange">el<font color="orange">if </font></font>(datatype =='i1'):<br>        data_flag = 1<br>    <font color="orange">el<font color="orange">if </font></font>(datatype =='f4'):<br>        data_flag = 2<br>    <font color="orange">el<font color="orange">if </font></font>(datatype =='c'):<br>        data_flag = 3<br>    <font color="orange">el<font color="orange">if </font></font>(datatype =='f4'):<br>        data_flag = 4<br>    <font color="orange">el<font color="orange">if </font></font>(datatype =='u2'):<br>        data_flag = 6<br>    else:<br>        raise ValueError("No supported datatype found!\n")<br><br>    int_header[:4] = (dimx,dimy,dimz,data_flag)<br>    char_header = str(' '*800)<br>    <font color="orange">with </font>open(filename,'wb') as fid:<br>        fid.write(int_header.tobytes())<br>        fid.write(char_header.encode('UTF-8'))<br>        fid.write(arr.tobytes(order=order))<br><br><br><font color="orange">def </font>loadProjections(filename):<br>    """<br>    * loadProjections *<br><br>    Wrapper function for loading in projections of arbitrary (supported) extension<br><br>    :param filename: Filename of images to load<br>    :return: NumPy array containing projections<br><br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright 2015-2016. All rights reserved.<br>    """<br>    <font color="orange">import </font>os<br>    filename, file_extension = os.path.splitext(filename)<br>    <font color="orange">if </font>file_extension == ".mat":<br>        print ("Reading projections <font color="orange">from </font>MATLAB file.\n")<br>        # return readMAT_projections(filename + file_extension)<br>        return readMAT_volume(filename + file_extension)<br>    <font color="orange">el<font color="orange">if </font></font>file_extension == ".tif":<br>        print ("Reading projections <font color="orange">from </font>.t<font color="orange">if </font>file.\n")<br>        return readTIFF_projections(filename + file_extension)<br>    <font color="orange">el<font color="orange">if </font></font>file_extension == ".mrc":<br>        print ("Reading projections <font color="orange">from </font>.mrc file.\n")<br>        return readMRC(filename + file_extension)<br>    <font color="orange">el<font color="orange">if </font></font>file_extension == ".npy":<br>        print ("Reading projections <font color="orange">from </font>.npy file.\n")<br>        return readNPY(filename + file_extension)<br>    else:<br>        raise Exception('File format %s not supported.', file_extension)<br><br># def readMAT_projections(filename):<br>#     """<br>#     * readMAT *<br>#<br>#     Read projections from a .mat file<br>#<br>#     :param filename: MATLAB file (.mat) containing projections<br>#     :return: NumPy array containing projections<br>#<br>#<br>#     Author: Alan (AJ) Pryor, Jr.<br>#     Jianwei (John) Miao Coherent Imaging Group<br>#     University of California, Los Angeles<br>#     Copyright 2015-2016. All rights reserved.<br>#     """<br>#<br>#     import scipy.io<br>#     import numpy as np<br>#     import os<br>#     try: #try to open the projections as a stack<br>#         projections = scipy.io.loadmat(filename)<br>#         key = None<br>#         for k in projections.keys():<br>#             if k[0] != "_":<br>#                 key = k<br>#                 break<br>#<br>#         projections = np.array(projections[key])<br>#     except: ## -- figure out where error is thrown<br>#          #check if the projections are in individual files<br>#         flag = True<br>#         filename_base, file_extension = os.path.splitext(filename)<br>#         projectionCount = 1<br>#         while flag: #first count the number of projections so the array can be initialized<br>#             projectionCount = projectionCount<br>#             nextFile = filename_base + str(projectionCount) + file_extension<br>#             if os.path.isfile(nextFile):<br>#                 projectionCount += 1<br>#             else:<br>#                 flag = False<br>#<br>#<br>#         ## open first projection to get dimensions<br>#         pj = scipy.io.loadmat(filename_base + str(1) + file_extension)<br>#         pj = pj[projections.keys()[0]]<br>#         dims = np.shape(pj)<br>#         #initialize projection array<br>#         projections = np.zeros((dims[0], dims[1], projectionCount),dtype=int)<br>#<br>#         #now actually load in the tiff images<br>#         for projNum in range(projectionCount):<br>#             nextFile = filename_base + str(projNum) + file_extension<br>#             pj = scipy.io.loadmat(filename_base + str(projNum) + file_extension)<br>#             pj = pj[pj.keys()[0]]<br>#             projections[:, :, projNum] = np.array(pj)<br>#<br>#     return projections<br><br><br><font color="orange">def </font>readTIFF_projections(filename):<br>    """<br>    * readTIFF *<br><br>    Read (possibly multiple) TIFF images into a NumPy array<br><br>    :param filename: Name of TIFF file or TIFF file basename to read. If the filename is a base then<br>    #       the images must begin with the string contained in filename followed by consecutive integers with<br>    #       no zero padding, i.e. foo1.tiff, foo2.tiff,..., foo275.tiff<br>    :return: NumPy array containing projections<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright 2015-2016. All rights reserved.<br>    """<br>    <font color="orange">import </font>functools<br>    <font color="orange">from </font>PIL <font color="orange">import </font>Image<br>    <font color="orange">import </font>os<br>    <font color="orange">import </font>numpy as np<br>    <font color="orange">from </font>multiprocessing <font color="orange">import </font>Pool<br>    try:<br>        projections = np.array(Image.open(filename))<br>    except:<br>        flag = <font color="orange">True<br></font>        filename_base, file_extension = os.path.splitext(filename)<br>        projectionCount = 1<br>        <font color="orange">while </font>flag: #first count the number of projections so the array can be initialized<br>            projectionCount = projectionCount<br>            nextFile = filename_base + str(projectionCount) + file_extension<br>            <font color="orange">if </font>os.path.isfile(nextFile):<br>                projectionCount += 1<br>            else:<br>                flag = <font color="orange">False<br></font><br>        ## open first projection to get dimensions<br>        dims = np.shape(Image.open(filename_base + str(1) + file_extension))<br><br>        #initialize projection array<br>        projections = np.zeros((dims[0], dims[1], projectionCount),dtype=int)<br><br>        pool = Pool(4)<br>        func = functools.partial(readInTiffProjection, filename_base)<br>        pj = pool.map(func, range(projectionCount))<br>        <font color="orange">for </font>j  in range(projectionCount):<br>            projections[:, :, j] = pj[j]<br>    return projections<br><br><font color="orange">def </font>readInTiffProjection(filename_base, fileNumber):<br>    """<br>    * readInTiffProjection *<br><br>    Reads and returns a single TIFF image as a NumPy array<br><br>    :param filename_base: Base filename of TIFF<br>    :param fileNumber: Image number<br>    :return: Image in a 2D NumPy array<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright 2015-2016. All rights reserved.<br>    """<br>    <font color="orange">from </font>PIL <font color="orange">import </font>Image<br>    <font color="orange">import </font>numpy as np<br>    nextFile = filename_base + str(fileNumber) + '.tif'<br>    return np.array(Image.open(nextFile))<br><br><font color="orange">def </font>loadAngles(filename):<br>    """<br>    * loadAngles *<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright 2015-2016. All rights reserved.<br><br>    :param filename:<br>    :return:<br>    """<br>    <font color="orange">import </font>os<br>    base,ext = os.path.splitext(filename)<br>    ext = ext.lower()<br>    <font color="orange">if </font>ext == ".txt":<br>        return np.loadtxt(filename,dtype=float)<br>    <font color="orange">el<font color="orange">if </font></font>ext== ".npy":<br>        return np.load(filename)<br>    <font color="orange">el<font color="orange">if </font></font>ext==".mat":<br>        <font color="orange">from </font><b><font color="orange">GENFIRE</font></b>.fileio <font color="orange">import </font>readVolume<br>        return readVolume(filename)<br>    else:<br>        raise IOError("Unsupported file extension \"{}\" <font color="orange">for </font>Euler angles".format(ext))<br><br><br><font color="orange">def </font>saveResults(reconstruction_outputs, filename):<br>    """<br>    * saveResults *<br><br>    Helper function to save results of GENFIRE reconstruction<br><br>    :param reconstruction_outputs: dictionary containing reconstruction, reciprocal error (errK), and possible R_free<br>    :param filename: Output filename<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright 2015-2016. All rights reserved<br>    """<br>    <font color="orange">import </font>os<br>    fn, ext = os.path.splitext(filename)<br>    writeVolume(filename, reconstruction_outputs['reconstruction'])<br>    np.savetxt(fn+'_errK.txt',reconstruction_outputs['errK'])<br>    <font color="orange">if </font>'R_free_total' in reconstruction_outputs.keys():<br>        np.savetxt(fn+'_Rfree_total.txt',reconstruction_outputs['R_free_total'])<br>        np.savetxt(fn+'_Rfree_bybin.txt',reconstruction_outputs['R_free_bybin'])<br><br><font color="orange">def </font>writeVolume(filename, data, order="C"):<br>    """<br>    * writeVolume *<br><br>    Wrapper volume to file<br><br>    :param filename: output filename with valid extension<br>    :param data: numpy volume to write<br>    :param order: "C" for row-major order (C-style), "F" for column-major (Fortran style)<br>    """<br>    <font color="orange">import </font>os<br>    fn, ext = os.path.splitext(filename)<br>    <font color="orange">if </font>ext == ".mrc":<br>        writeMRC(filename, arr=data, order=order)<br>    <font color="orange">el<font color="orange">if </font></font>ext == ".npy":<br>        <font color="orange">import </font>numpy as np<br>        np.save(filename,data)<br>    <font color="orange">el<font color="orange">if </font></font>ext == ".mat":<br>        <font color="orange">import </font>scipy.io<br>        scipy.io.savemat(filename, {"data":data})<br>    else:<br>        raise IOError("Unsupported file extension \"{}\" <font color="orange">for </font>volume object".format(ext))<br></code></body>
    </html>