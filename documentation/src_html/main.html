<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>..//GENFIRE/main</title>
  <meta name="description" content="GENFIRE Documentation">
  <meta name="author" content="Alan (AJ) Pryor, Jr.">  <link rel="stylesheet" href="css/styles.css?v=1.0">
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
<code>"""<br>* GENFIRE.main *<br><br>The primary control module for running GENFIRE reconstructions.<br><br><br>Author: Alan (AJ) Pryor, Jr.<br>Jianwei (John) Miao Coherent Imaging Group<br>University of California, Los Angeles<br>Copyright 2015-2016. All rights reserved.<br>"""<br><br><font color="orange">from </font>__future__ <font color="orange">import </font>division<br><font color="orange">import </font>numpy as np<br><font color="orange">import </font><b><font color="orange">GENFIRE</font></b><br><font color="orange">import </font>sys<br><font color="orange">import </font>os<br><font color="orange">from </font><b><font color="orange">GENFIRE</font></b>.reconstruct <font color="orange">import </font>ReconstructionParameters<br><br><br><font color="orange">def </font>main_InteractivelySetParameters():<br>    #######################################################################################################################<br>    ############################################### User Parameters  ######################################################<br>    #######################################################################################################################<br><br>    # GENFIRE's reconstruction parameters can be edited here by the user and run interactively, any inputs provided<br>    # by either the command line or the GUI will override these momentarily<br><br>    filename_projections = '../data/projections.mat'  #filename of projections, which should be size NxNxN_projections where N_projections is the number of projections<br>    filename_angles = '../data/angles.mat'  #angles can be either a 1xN_projections array containing a single tilt series, or 3xN_projections array containing 3 Euler angles for each projections in the form [phi;theta;psi]<br>    filename_support = '../data/support60.mat'  #NxNxN binary array specifying a region of 1's in which the reconstruction can exist<br>    filename_initialObject = None  #initial object to use in reconstruction; set to None to provide no initial guess<br>    filename_results = '<b><font color="orange">GENFIRE</font></b>_rec.mrc'  #filename to save results<br>    resolutionExtensionSuppressionState = 2 # 1) Turn on resolution extension/suppression, 2) No resolution extension/suppression, 3) Just resolution extension<br><br>    numIterations = 100  #number of iterations to run in iterative reconstruction<br>    oversamplingRatio = 3  #input projections will be padded internally to match this oversampling ratio. If you prepad your projections, set this to 1<br>    interpolationCutoffDistance = 0.7  #radius of spherical interpolation kernel (in pixels) within which to include measured datapoints<br>    doYouWantToDisplayFigure = True<br>    displayFigure = <b><font color="orange">GENFIRE</font></b>.reconstruct.DisplayFigure()<br>    displayFigure.DisplayFigureON = doYouWantToDisplayFigure<br>    calculateRFree = True<br>    <font color="orange">if </font>filename_support is None:<br>        useDefaultSupport = True<br>    else:<br>        useDefaultSupport = False<br><br>    reconstruction_parameters                                      = ReconstructionParameters()<br>    reconstruction_parameters.projectionFilename                   = filename_projections<br>    reconstruction_parameters.angleFilename                        = filename_angles<br>    reconstruction_parameters.supportFilename                      = filename_support<br>    reconstruction_parameters.interpolationCutoffDistance          = interpolationCutoffDistance<br>    reconstruction_parameters.numIterations                        = numIterations<br>    reconstruction_parameters.oversamplingRatio                    = oversamplingRatio<br>    reconstruction_parameters.displayFigure                        = displayFigure<br>    reconstruction_parameters.calculateRfree                       = calculateRFree<br>    reconstruction_parameters.resolutionExtensionSuppressionState  = resolutionExtensionSuppressionState<br>    reconstruction_parameters.useDefaultSupport                    = useDefaultSupport<br>    <font color="orange">if </font>os.path.isfile(filename_results): # If a valid initial object was provided, use it<br>        reconstruction_parameters.initialObjectFilename           = filename_results<br><br>    main(reconstruction_parameters)<br><br><font color="orange">def </font>main(reconstruction_parameters):<br>    <font color="orange">import </font><b><font color="orange">GENFIRE</font></b>.fileio<br><br>    filename_projections                    = reconstruction_parameters.projectionFilename<br>    filename_angles                         = reconstruction_parameters.angleFilename<br>    filename_support                        = reconstruction_parameters.supportFilename<br>    filename_results                        = reconstruction_parameters.resultsFilename<br>    numIterations                           = reconstruction_parameters.numIterations<br>    oversamplingRatio                       = reconstruction_parameters.oversamplingRatio<br>    interpolationCutoffDistance             = reconstruction_parameters.interpolationCutoffDistance<br>    displayFigure                           = reconstruction_parameters.displayFigure<br>    resolutionExtensionSuppressionState     = reconstruction_parameters.resolutionExtensionSuppressionState<br>    calculateRFree                          = reconstruction_parameters.calculateRfree<br>    useDefaultSupport                       = reconstruction_parameters.useDefaultSupport<br>    use_positivity                          = reconstruction_parameters.constraint_positivity<br>    use_support                             = reconstruction_parameters.constraint_support<br>    gridding_method                         = reconstruction_parameters.griddingMethod<br>    enforceResolutionCircle                 = reconstruction_parameters.enforceResolutionCircle<br>    permitMultipleGridding                  = reconstruction_parameters.permitMultipleGridding<br><br>    <font color="orange">if </font>reconstruction_parameters.isInitialObjectDefined:<br>            filename_initialObject          = reconstruction_parameters.initialObjectFilename<br>    else:<br>        filename_initialObject               = None<br><br>    ### begin reconstruction ###<br>    projections = <b><font color="orange">GENFIRE</font></b>.fileio.loadProjections(filename_projections) # load projections into a 3D numpy array<br><br>    # get dimensions of array and determine the array size after padding<br>    dims = np.shape(projections)<br>    paddedDim = dims[0] * oversamplingRatio<br>    padding = int((paddedDim-dims[0])/2)<br><br>    # load the support, or generate one if none was provided<br>    <font color="orange">if </font>useDefaultSupport or filename_support == "":<br>        support = np.ones((dims[0],dims[0],dims[0]),dtype=float)<br>    else:<br>        support = (<b><font color="orange">GENFIRE</font></b>.fileio.readVolume(filename_support) != 0).astype(bool)<br><br>    displayFigure.reconstructionDisplayWindowSize = np.shape(support) # this is used to show the central region of reconstruction<br><br>    # now zero-pad to match the oversampling ratio<br>    support = np.pad(support,((padding,padding),(padding,padding),(padding,padding)),'constant')<br>    projections = np.pad(projections,((padding,padding),(padding,padding),(0,0)),'constant')<br><br>    #load initial object, or initialize it to zeros if none was given<br>    <font color="orange">if </font>filename_initialObject is not None and os.path.isfile(filename_initialObject):<br>        initialObject = <b><font color="orange">GENFIRE</font></b>.fileio.readVolume(filename_initialObject)<br>        initialObject = np.pad(initialObject,((padding,padding),(padding,padding),(padding,padding)),'constant')<br>    else:<br>        initialObject = np.zeros_like(support)<br><br>    # load angles and check that the dimensions match the number of provided projections and that they<br>    # are either 1 x num_projections or 3 x num_projections<br>    angles = <b><font color="orange">GENFIRE</font></b>.fileio.loadAngles(filename_angles)<br>    <font color="orange">if </font>np.shape(angles)[1] > 3:<br>        raise ValueError("Error! Dimension of angles incorrect.")<br>    <font color="orange">if </font>np.shape(angles)[1] == 1:<br>        tmp = np.zeros([np.shape(angles)[1], 3])<br>        tmp[1, :] = angles<br>        angles = tmp<br>        <font color="orange">del </font>tmp<br><br>    # grid the projections<br>    <font color="orange">if </font>gridding_method == "DFT":<br>        measuredK = <b><font color="orange">GENFIRE</font></b>.reconstruct.fillInFourierGrid_DFT(projections, angles, interpolationCutoffDistance, enforceResolutionCircle)<br>    else:<br>        measuredK = <b><font color="orange">GENFIRE</font></b>.reconstruct.fillInFourierGrid(projections, angles, interpolationCutoffDistance, enforceResolutionCircle, permitMultipleGridding)<br><br>    # the grid is assembled with the origin at the geometric center of the array, but for efficiency in the<br>    # iterative algorithm the origin is shifted to array position [0,0,0] to avoid unnecessary fftshift calls<br>    measuredK = np.fft.ifftshift(measuredK)<br><br>    # create a map of the spatial frequency to be used to control resolution extension/suppression behavior<br>    K_indices = <b><font color="orange">GENFIRE</font></b>.utility.generateKspaceIndices(support)<br>    K_indices = np.fft.fftshift(K_indices)<br>    resolutionIndicators = np.zeros_like(K_indices)<br>    resolutionIndicators[measuredK != 0] = 1-K_indices[measuredK != 0]<br><br>    # if calculating Rfree, setup some infrastructure<br>    <font color="orange">if </font>calculateRFree:<br>        R_freeInd_complexX = []<br>        R_freeInd_complexY = []<br>        R_freeInd_complexZ = []<br>        R_freeVals_complex = []<br>        shell_thickness_pixels = 1 # pixel thickness of an individual shell of Rfree points<br>        numberOfBins = int(round(dims[0]/2/shell_thickness_pixels)) # number of frequency bins. Rfree will be tracked within each shell separately<br>        percentValuesForRfree = 0.05 # percentage of measured points to withhold<br>        spatialFrequencyForRfree = np.linspace(0,1,numberOfBins+1)<br>        K_indicesSmall =(K_indices)[:, :, 0:(np.shape(measuredK)[-1]//2+1)]<br><br>        <font color="orange">for </font>shellNum in range(0,numberOfBins):<br>            # collect relevant points<br>            measuredPointInd_complex = np.where((measuredK[:, :, 0:(np.shape(measuredK)[-1]//2+1)] != 0) & (K_indicesSmall>=(spatialFrequencyForRfree[shellNum])) & (K_indicesSmall<=(spatialFrequencyForRfree[shellNum+1])))<br><br>            # randomly shuffle<br>            shuffledPoints = np.random.permutation(np.shape(measuredPointInd_complex)[1])<br>            measuredPointInd_complex = (measuredPointInd_complex[0][shuffledPoints], measuredPointInd_complex[1][shuffledPoints], measuredPointInd_complex[2][shuffledPoints])<br><br>            # determine how many values to take<br>            cutoffInd_complex = np.floor(np.shape(measuredPointInd_complex)[1] * percentValuesForRfree).astype(int)<br><br>            # collect the Rfree values and coordinates<br>            R_freeInd_complexX.append(measuredPointInd_complex[0][:cutoffInd_complex])<br>            R_freeInd_complexY.append(measuredPointInd_complex[1][:cutoffInd_complex])<br>            R_freeInd_complexZ.append(measuredPointInd_complex[2][:cutoffInd_complex])<br>            R_freeVals_complex.append(measuredK[R_freeInd_complexX[shellNum], R_freeInd_complexY[shellNum], R_freeInd_complexZ[shellNum] ])<br><br>            # delete the points from the measured data<br>            measuredK[R_freeInd_complexX[shellNum], R_freeInd_complexY[shellNum], R_freeInd_complexZ[shellNum]] = 0<br><br>        # create tuple of coordinates<br>        R_freeInd_complex = [[R_freeInd_complexX], [R_freeInd_complexY], [R_freeInd_complexZ]]<br>        <font color="orange">del </font>R_freeInd_complexX<br>        <font color="orange">del </font>R_freeInd_complexY<br>        <font color="orange">del </font>R_freeInd_complexZ<br>    else:<br>        R_freeInd_complex = []<br>        R_freeVals_complex = []<br><br>    <font color="orange">if </font>resolutionExtensionSuppressionState==1: # resolution extension/suppression<br>        constraintEnforcementDelayIndicators = np.array(np.concatenate((np.arange(0.95, -.25, -0.15), np.arange(-0.15, .95, .1)), axis=0))<br>    <font color="orange">el<font color="orange">if </font></font>resolutionExtensionSuppressionState==2:# no resolution extension or suppression<br>        constraintEnforcementDelayIndicators = np.array([-999, -999, -999, -999])<br>    <font color="orange">el<font color="orange">if </font></font>resolutionExtensionSuppressionState==3:# resolution extension only<br>        constraintEnforcementDelayIndicators = np.concatenate((np.arange(0.95, -.15, -0.15),[-0.15, -0.15, -0.15]))<br>    else:<br>        print("Warning! Input resolutionExtensionSuppressionState does not match an available option. Deactivating dynamic constraint enforcement and continuing.\n")<br>        constraintEnforcementDelayIndicators = np.array([-999, -999, -999, -999])<br><br>    reconstructionOutputs = <b><font color="orange">GENFIRE</font></b>.reconstruct.reconstruct(numIterations, np.fft.fftshift(initialObject), np.fft.fftshift(support), (measuredK)[:, :, 0:(np.shape(measuredK)[-1] // 2 + 1)], (resolutionIndicators)[:, :, 0:(np.shape(measuredK)[-1] // 2 + 1)], constraintEnforcementDelayIndicators, R_freeInd_complex, R_freeVals_complex, displayFigure, use_positivity, use_support)<br><br>    # reclaim original array size. ncBig is center of oversampled array, and n2 is the half-width of original array<br>    ncBig = paddedDim//2<br>    n2 = dims[0]//2<br>    reconstructionOutputs['reconstruction'] = reconstructionOutputs['reconstruction'][ncBig-n2:ncBig+n2,ncBig-n2:ncBig+n2,ncBig-n2:ncBig+n2]<br>    <b><font color="orange">GENFIRE</font></b>.fileio.saveResults(reconstructionOutputs, filename_results)<br><br><font color="orange">if </font>__name__ == "__main__" and len(sys.argv) == 1:<br>    print ("starting <font color="orange">with </font>user parameters")<br>    main_InteractivelySetParameters()<br><font color="orange">el<font color="orange">if </font></font>__name__ == "__main__":<br>    <font color="orange">if </font>len(sys.argv) > 1: # Parse inputs provided either from the GUI or from the command line<br>        inputArgumentOptions = {"-p" :  "filename_projections",<br>                                "-a" :  "filename_angles",<br>                                "-s" :  "filename_support",<br>                                "-o" :  "filename_results",<br>                                "-i" :  "filename_initialObject",<br>                                "-r" :  "resolutionExtensionSuppressionState",<br>                                "-it":  "numIterations",<br>                                "-or":  "oversamplingRatio",<br>                                "-t" :  "interpolationCutoffDistance",<br>                                "-d" :  "displayFigure",<br>                                "-rf":  "calculateRFree"<br>                                }<br>        print (sys.argv[:])<br>        <font color="orange">if </font>len(sys.argv)%2==0:<br>            raise Exception("Number of input options and input arguments does not match!")<br>        <font color="orange">for </font>argumentNum in range(1,len(sys.argv),2):<br>            print (inputArgumentOptions[sys.argv[argumentNum]])<br>            print  (sys.argv[argumentNum+1])<br>            print (inputArgumentOptions[sys.argv[argumentNum]] + "=" + sys.argv[argumentNum+1])<br><br><br>            exec(inputArgumentOptions[sys.argv[argumentNum]] + "= '" + sys.argv[argumentNum+1] +"'")<br>            print("Setting argument %s <font color="orange">from </font>option %s equal to <b><font color="orange">GENFIRE</font></b> parameter %s " % (sys.argv[argumentNum+1],sys.argv[argumentNum], inputArgumentOptions[sys.argv[argumentNum]] ))<br><br>        numIterations = int(numIterations)<br>        # displayFigure = bool(displayFigure)<br>        doYouWantToDisplayFigure = bool(displayFigure)<br>        displayFigure = <b><font color="orange">GENFIRE</font></b>.reconstruct.DisplayFigure()<br>        displayFigure.DisplayFigureON = doYouWantToDisplayFigure<br>        oversamplingRatio = float(oversamplingRatio)<br>        resolutionExtensionSuppressionState = int(resolutionExtensionSuppressionState)<br>        calculateRFree = bool(calculateRFree)<br>        try:<br>            main(filename_projections,<br>                 filename_angles,<br>                 filename_support,<br>                 filename_results,<br>                 numIterations,<br>                 oversamplingRatio,<br>                 interpolationCutoffDistance,<br>                 resolutionExtensionSuppressionState,<br>                 displayFigure,<br>                 calculateRFree,<br>                 filename_initialObject)<br>        except (NameError, IOError):<br>             main(filename_projections,<br>                  filename_angles,<br>                  filename_support,<br>                  filename_results,<br>                  numIterations,<br>                  oversamplingRatio,<br>                  interpolationCutoffDistance,<br>                  resolutionExtensionSuppressionState,<br>                  displayFigure,<br>                  calculateRFree)</code></body>
    </html>