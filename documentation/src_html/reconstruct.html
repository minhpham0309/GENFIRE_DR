<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>..//GENFIRE/reconstruct</title>
  <meta name="description" content="GENFIRE Documentation">
  <meta name="author" content="Alan (AJ) Pryor, Jr.">  <link rel="stylesheet" href="css/styles.css?v=1.0">
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
<code>"""<br>* GENFIRE.reconstruct *<br><br>This module contains the core of GENFIRE's functions for computing reconstructions<br><br><br>Author: Alan (AJ) Pryor, Jr.<br>Jianwei (John) Miao Coherent Imaging Group<br>University of California, Los Angeles<br>Copyright 2015-2016. All rights reserved.<br>"""<br><br><br><font color="orange">from </font>__future__ <font color="orange">import </font>division<br><font color="orange">import </font>matplotlib<br>matplotlib.use("Qt4Agg")<br><font color="orange">import </font>matplotlib.pyplot as <font color="orange">plt<br></font><font color="orange">import </font>os<br><font color="orange">import </font>scipy.io<br><font color="orange">import </font>time<br><font color="orange">import </font><b><font color="orange">GENFIRE</font></b><br><font color="orange">from </font>multiprocessing <font color="orange">import </font>Pool<br><font color="orange">from </font><b><font color="orange">GENFIRE</font></b>.utility <font color="orange">import </font>*<br><br>PI = np.pi<br><font color="orange">if </font>__name__ != "__main__":<br>    <font color="orange">def </font>reconstruct(numIterations, initialObject, support, measuredK, constraintIndicators, constraintEnforcementDelayIndicators, R_freeInd_complex, R_freeVals_complex, displayFigure, use_positivity=True, use_support=True):<br>        """<br>         * reconstruct *<br><br>         Primary GENFIRE reconstruction function<br><br>        :param numIterations: Integer number of iterations to run<br>        :param initialObject: Initial guess of 3D object<br>        :param support: Binary matrix representing where the object is allowed to exist<br>        :param measuredK: Assembled 3D Fourier grid<br>        :param constraintIndicators: Flag value for each datapoint used to control during which iterations a given Fourier component is enforced<br>        :param constraintEnforcementDelayIndicators: List of cutoff values that will be divided evenly among the iterations. All Fourier grid points with constraintIndicators greater than the current cutoff are enforced<br>        :param R_freeInd_complex: 3 x 1 x num_shells tuple of (x,y,z) coordinate lists for withheld values for Rfree calculation<br>        :param R_freeVals_complex: Complex valued component at the indices given by R_freeInd_complex<br>        :param displayFigure: Boolean flag to display figures during the reconstruction<br>        :return: outputs dictionary containing the reconstruction and error metrics<br><br>         Author: Alan (AJ) Pryor, Jr.<br>         Jianwei (John) Miao Coherent Imaging Group<br>         University of California, Los Angeles<br>         Copyright 2015-2016. All rights reserved.<br>        """<br>        <font color="orange">import </font>time<br>        t0 = time.time()<br>        print("Reconstruction started")<br>        bestErr = 1e30 #initialize error<br><br>        #initialize arrays for error metrics<br>        Rfree_complex = np.ones(numIterations)*-1 #<br>        errK = np.zeros(numIterations)<br><br>        #prefetch indices for monitoring error<br>        errInd = measuredK != 0<br><br>        #get dimensions of object<br>        dims = np.shape(support)<br>        <font color="orange">if </font>R_freeInd_complex:<br>            Rfree_complex_bybin = np.zeros((np.shape(R_freeInd_complex)[2], numIterations),dtype=float)<br>            Rfree_complex_total = np.zeros(numIterations,dtype=float)<br><br>        <font color="orange">if </font>displayFigure.DisplayFigureON: #setup some indices for plotting.<br>            n_half_x = int(dims[0]/2) #this assumes even-sized arrays<br>            n_half_y = int(dims[1]/2)<br>            n_half_z = int(dims[2]/2)<br><br>            half_window_x = displayFigure.reconstructionDisplayWindowSize[0]//2<br>            half_window_y = displayFigure.reconstructionDisplayWindowSize[1]//2<br>            half_window_z = displayFigure.reconstructionDisplayWindowSize[2]//2<br><br>        #setup output dict<br>        <font color="orange">if </font>R_freeInd_complex:<br>            outputs = {'reconstruction':initialObject,'errK':errK,'R_free_bybin':Rfree_complex_bybin, "R_free_total":Rfree_complex_total}<br>        else:<br>            outputs = {'reconstruction':initialObject,'errK':errK}<br><br>        #determine how to divide up the constraint enforcement cutoffs among the iterations by determining<br>        #which iterations will require a recalculation of the indices to enforce<br>        iterationNumsToChangeCutoff = np.round(np.linspace(1, numIterations, num=np.size(constraintEnforcementDelayIndicators)))<br>        iterationNumsToChangeCutoff, uniqueIndices = np.unique(iterationNumsToChangeCutoff, return_index=True)<br>        iterationNumsToChangeCutoff = np.append(iterationNumsToChangeCutoff,1e30) #add an arbitrarily high number to the end that is an iteration number that won't be reached<br>        constraintEnforcementDelayIndicators = constraintEnforcementDelayIndicators[uniqueIndices]<br>        currentCutoffNum = 0<br>        <font color="orange">for </font>iterationNum in range(1, numIterations+1): #iterations are counted started from 1<br><br>            <font color="orange">if </font>iterationNum == iterationNumsToChangeCutoff[currentCutoffNum]: #update current Fourier constraint if appropriate<br>                relevantCutoff = constraintEnforcementDelayIndicators[currentCutoffNum]<br>                constraintInd_complex = (constraintIndicators > relevantCutoff) * measuredK != 0<br><br>                bestErr = 1e30 #reset error<br>                currentCutoffNum+=1#update constraint set number<br><br>            <font color="orange">if </font>use_positivity:<br>                initialObject[initialObject<0] = 0 #enforce positivity<br>            <font color="orange">if </font>use_support:<br>                initialObject = initialObject * support #enforce support<br><br>            #take FFT of current reconstruction<br>            k = rfftn(initialObject)<br><br>            #compute error<br>            errK[iterationNum-1] = np.sum(abs(k[errInd]-measuredK[errInd]))/np.sum(abs(measuredK[errInd]))#monitor error<br>            print("Iteration number: {0}           error = {1:0.5f}".format(iterationNum, errK[iterationNum-1]))<br><br>            #update best object if a better one has been found<br>            <font color="orange">if </font>errK[iterationNum-1] < bestErr:<br>                bestErr = errK[iterationNum-1]<br>                outputs['reconstruction'] = initialObject<br><br>            #calculate Rfree for each spatial frequency shell if necessary<br>            <font color="orange">if </font>R_freeInd_complex:<br>                total_Rfree_error      = 0<br>                total_Rfree_error_norm = 0<br>                <font color="orange">for </font>shellNum in range(0, np.shape(R_freeInd_complex)[2]):<br><br>                    tmpIndX = R_freeInd_complex[0][0][shellNum]<br>                    tmpIndY = R_freeInd_complex[1][0][shellNum]<br>                    tmpIndZ = R_freeInd_complex[2][0][shellNum]<br><br>                    tmpVals = R_freeVals_complex[shellNum]<br>                    Rfree_numerator                         = np.sum(abs(k[tmpIndX, tmpIndY, tmpIndZ] - tmpVals))<br>                    Rfree_denominator                       = np.sum(abs(tmpVals))<br>                    total_Rfree_error                      += Rfree_numerator<br>                    total_Rfree_error_norm                 += Rfree_denominator<br>                    Rfree_complex_bybin[shellNum, iterationNum-1] = Rfree_numerator / Rfree_denominator<br>                Rfree_complex_total[iterationNum-1] = total_Rfree_error / total_Rfree_error_norm<br>            #replace Fourier components with ones from measured data from the current set of constraints<br>            k[constraintInd_complex] = measuredK[constraintInd_complex]<br>            initialObject = irfftn(k)<br><br>            #update display<br>            <font color="orange">if </font>displayFigure.DisplayFigureON:<br>                <font color="orange">if </font>iterationNum % displayFigure.displayFrequency == 0:<br>                    print("n_half_x = ", n_half_x)<br>                    print("half_window_y = ", half_window_y)<br>                    <font color="orange">plt.</font>figure(1000)<br>                    <font color="orange">plt.</font>subplot(233)<br>                    <font color="orange">plt.</font>imshow(np.squeeze(np.fft.fftshift(initialObject)[n_half_x, n_half_y-half_window_y:n_half_y+half_window_y, n_half_z-half_window_z:n_half_z+half_window_z]))<br>                    <font color="orange">plt.</font>title("central YZ slice")<br><br>                    <font color="orange">plt.</font>subplot(232)<br>                    <font color="orange">plt.</font>imshow(np.squeeze(np.fft.fftshift(initialObject)[n_half_x-half_window_x:n_half_x+half_window_x, n_half_y, n_half_z-half_window_z:n_half_z+half_window_z]))<br>                    <font color="orange">plt.</font>title("central XZ slice")<br><br>                    <font color="orange">plt.</font>subplot(231)<br>                    <font color="orange">plt.</font>title("central XY slice")<br>                    <font color="orange">plt.</font>imshow(np.squeeze(np.fft.fftshift(initialObject)[n_half_x-half_window_x:n_half_x+half_window_x, n_half_y-half_window_y:n_half_y+half_window_y, n_half_z]))<br><br>                    <font color="orange">plt.</font>subplot(236)<br>                    <font color="orange">plt.</font>title("YZ projection")<br>                    <font color="orange">plt.</font>imshow(np.squeeze(np.sum(np.fft.fftshift(initialObject)[n_half_x-half_window_x:n_half_x+half_window_x, n_half_y-half_window_y:n_half_y+half_window_y, n_half_z-half_window_z:n_half_z+half_window_z], axis=0)))<br><br>                    <font color="orange">plt.</font>subplot(235)<br>                    <font color="orange">plt.</font>title("XZ projection")<br>                    <font color="orange">plt.</font>imshow(np.squeeze(np.sum(np.fft.fftshift(initialObject)[n_half_x-half_window_x:n_half_x+half_window_x, n_half_y-half_window_y:n_half_y+half_window_y, n_half_z-half_window_z:n_half_z+half_window_z], axis=1)))<br><br>                    <font color="orange">plt.</font>subplot(234)<br>                    <font color="orange">plt.</font>title("XY projection")<br>                    <font color="orange">plt.</font>imshow(np.squeeze(np.sum(np.fft.fftshift(initialObject)[n_half_x-half_window_x:n_half_x+half_window_x, n_half_y-half_window_y:n_half_y+half_window_y, n_half_z-half_window_z:n_half_z+half_window_z], axis=2)))<br>                    <font color="orange">plt.</font>get_current_fig_manager().window.setGeometry(25,25,400, 400)<br>                    <font color="orange">plt.</font>draw()<br><br>                    <font color="orange">plt.</font>figure(2)<br>                    <font color="orange">plt.</font>get_current_fig_manager().window.setGeometry(25,450,400, 400)<br>                    <font color="orange">plt.</font>hold(False)<br>                    <font color="orange">plt.</font>plot(range(0,numIterations),errK)<br>                    <font color="orange">plt.</font>title("K-space Error vs Iteration Number")<br>                    <font color="orange">plt.</font>xlabel("Spatial Frequency (% of Nyquist)")<br>                    <font color="orange">plt.</font>ylabel('Reciprocal Space Error')<br>                    <font color="orange">plt.</font>draw()<br><br>                    <font color="orange">if </font>R_freeInd_complex:<br>                        <font color="orange">plt.</font>figure(3)<br>                        mngr = <font color="orange">plt.</font>get_current_fig_manager()<br>                        mngr.window.setGeometry(450,25,400, 400)<br>                        <font color="orange">plt.</font>plot(range(0,numIterations),Rfree_complex_total)<br>                        <font color="orange">plt.</font>title("Mean R-free Value vs Iteration Number")<br>                        <font color="orange">plt.</font>xlabel("Iteration Num")<br>                        <font color="orange">plt.</font>ylabel('Mean R-free')<br>                        <font color="orange">plt.</font>draw()<br><br>                        <font color="orange">plt.</font>figure(4)<br>                        mngr = <font color="orange">plt.</font>get_current_fig_manager()<br>                        mngr.window.setGeometry(450,450,400, 400)<br>                        <font color="orange">plt.</font>hold(False)<br>                        X = np.linspace(0,1,np.shape(Rfree_complex_bybin)[0])<br>                        <font color="orange">plt.</font>plot(X, Rfree_complex_bybin[:,iterationNum-1])<br>                        <font color="orange">plt.</font>hold(False)<br>                        <font color="orange">plt.</font>title("Current Rfree Value vs Spatial Frequency")<br>                        <font color="orange">plt.</font>xlabel("Spatial Frequency (% of Nyquist)")<br>                        <font color="orange">plt.</font>ylabel('Rfree')<br>                        <font color="orange">plt.</font>draw()<br><br><br>                    <font color="orange">plt.</font>pause(1e-30) #forces display to update<br><br>        outputs['errK'] = errK<br>        <font color="orange">if </font>R_freeInd_complex:<br>            outputs['R_free_bybin'] = Rfree_complex_bybin<br>            outputs['R_free_total'] = Rfree_complex_total<br>        outputs['reconstruction'] = np.fft.fftshift(outputs['reconstruction'])<br>        print("Reconstruction finished in {0:0.1f} seconds".format(time.time()-t0))<br>        return outputs<br><br><br>    <font color="orange">def </font>fillInFourierGrid(projections,angles,interpolationCutoffDistance, enforce_resolution_circle=True, permitMultipleGridding=True):<br>        """<br>        * fillInFourierGrid *<br><br>        FFT gridding function for converting a set of 2D projection images into a 3D Fourier grid<br><br>        :param projections: N x N x num_projections NumPy array containing the projections<br>        :param angles: 3 x num_projections NumPy array of Euler angles phi,theta, psi<br>        :param interpolationCutoffDistance: Radius of interpolation kernel. Only values within this radius of a grid point are considered<br>        :param enforce_resolution_circle: boolean; whether or not to truncate reciprocal space to Nyquist frequency<br>        :return: the assembled Fourier grid<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of California, Los Angeles<br>        Copyright 2015-2016. All rights reserved.<br><br>        """<br>        print ("Assembling Fourier grid.")<br>        tic = time.time()<br>        dim1 = np.shape(projections)[0]<br>        dim2 = np.shape(projections)[1]<br>        <font color="orange">if </font>len(np.shape(projections))>2:<br>            numProjections = np.shape(projections)[2]<br>        else:<br>            numProjections = 1<br>        nc = np.round(dim1/2)<br>        n2 = nc<br>        measuredX = np.zeros([dim1*dim2,numProjections])<br>        measuredY = np.zeros([dim1*dim2,numProjections])<br>        measuredZ = np.zeros([dim1*dim2,numProjections])<br>        kMeasured = np.zeros([dim1,dim1,numProjections], dtype=complex)<br>        # confidenceWeights = np.zeros([dim1,dim1,numProjections])<br>        ky,kx = np.meshgrid(np.arange(-n2,n2,1,dtype=float),np.arange(-n2,n2,1,dtype=float))<br>        Q = np.sqrt(ky**2+kx**2)/n2<br>        kx = np.reshape(kx, [1, dim1*dim2], 'F')<br>        ky = np.reshape(ky, [1, dim1*dim2], 'F')<br>        kz = np.zeros([1, dim1*dim1])<br>        <font color="orange">for </font>projNum in range(0, numProjections):<br><br>            # convert angles to radians and construct the rotation matrix<br>            phi = angles[projNum, 0] * PI/180<br>            theta = angles[projNum, 1] * PI/180<br>            psi = angles[projNum, 2] * PI/180<br>            R = np.array([[np.cos(psi)*np.cos(theta)*np.cos(phi)-np.sin(psi)*np.sin(phi) ,np.cos(psi)*np.cos(theta)*np.sin(phi)+np.sin(psi)*np.cos(phi)   ,    -np.cos(psi)*np.sin(theta)],<br>            [-np.sin(psi)*np.cos(theta)*np.cos(phi)-np.cos(psi)*np.sin(phi), -np.sin(psi)*np.cos(theta)*np.sin(phi)+np.cos(psi)*np.cos(phi) ,   np.sin(psi)*np.sin(theta) ],<br>            [np.sin(theta)*np.cos(phi)                               , np.sin(theta)*np.sin(phi)                                ,              np.cos(theta)]])<br>            R = R.T<br><br>            Kcoordinates = np.zeros([3, dim1*dim2],dtype=float)<br>            Kcoordinates[0, :] = kx<br>            Kcoordinates[1, :] = ky<br>            Kcoordinates[2, :] = kz<br><br><br>            rotkCoords = np.dot(R, Kcoordinates)<br>            measuredX[:, projNum] = rotkCoords[0, :]<br>            measuredY[:, projNum] = rotkCoords[1, :]<br>            measuredZ[:, projNum] = rotkCoords[2, :]<br>            kMeasured[:, :, projNum] = fftn_fftshift(projections[:, :, projNum])<br><br>        # reorganize the coordinates and discard any flagged values<br>        measuredX = np.reshape(measuredX,[1, np.size(kMeasured)], 'F')<br>        measuredY = np.reshape(measuredY,[1, np.size(kMeasured)], 'F')<br>        measuredZ = np.reshape(measuredZ,[1, np.size(kMeasured)], 'F')<br>        kMeasured = np.reshape(kMeasured,[1, np.size(kMeasured)], 'F')<br>        notFlaggedIndices = kMeasured != -999<br>        measuredX = measuredX[notFlaggedIndices]<br>        measuredY = measuredY[notFlaggedIndices]<br>        measuredZ = measuredZ[notFlaggedIndices]<br>        kMeasured = kMeasured[notFlaggedIndices]<br><br>        masterInd = []<br>        masterVals = []<br>        masterDistances = []<br><br>        # check whether we need to consider multiple grid points<br>        <font color="orange">if </font>permitMultipleGridding:<br>            shiftMax = int(round(interpolationCutoffDistance))<br>        else:<br>            shiftMax = 0<br>        <font color="orange">for </font>Yshift in range(-shiftMax, shiftMax+1):<br>            <font color="orange">for </font>Xshift in range(-shiftMax, shiftMax+1):<br>                <font color="orange">for </font>Zshift in range(-shiftMax, shiftMax+1):<br><br>                    tmpX = np.round(measuredX) + Xshift<br>                    tmpY = np.round(measuredY) + Yshift<br>                    tmpZ = np.round(measuredZ) + Zshift<br><br>                    tmpVals = kMeasured<br>                    # tmpConfidenceWeights = confidenceWeights<br>                    distances = np.abs(measuredX-tmpX)**2 + np.abs(measuredY-tmpY)**2 + np.abs(measuredZ-tmpZ)**2<br>                    tmpX+=nc<br>                    tmpY+=nc<br>                    tmpZ+=nc<br><br>                    goodInd = (np.logical_not((tmpX > (dim1-1)) | (tmpX < 0) | (tmpY > (dim1-1)) | (tmpY < 0) | (tmpZ > (dim1-1)) | (tmpZ < 0))) & (distances <= (interpolationCutoffDistance**2))<br><br>                    masterInd=np.append(masterInd, np.ravel_multi_index((tmpX[goodInd].astype(np.int64), tmpY[goodInd].astype(np.int64), tmpZ[goodInd].astype(np.int64)),[dim1, dim1, dim1], order='F'))<br>                    masterVals=np.append(masterVals, tmpVals[goodInd])<br>                    masterDistances=np.append(masterDistances, distances[goodInd])<br><br><br>        masterInd = np.array(masterInd).astype(np.int64)<br>        masterVals = np.array(masterVals)<br>        masterDistances = np.array(masterDistances)<br><br>        #  only assemble half of the grid and then fill the remainder by Hermitian symmetry<br>        halfwayCutoff = ((dim1+1)**3)//2+1<br>        masterVals = masterVals[masterInd <= halfwayCutoff]<br>        masterDistances = masterDistances[masterInd <= halfwayCutoff]<br>        masterDistances = masterDistances +  1e-5<br>        masterDistances [masterDistances != 0 ]  = 1 / masterDistances[masterDistances != 0 ]<br>        masterInd = masterInd[masterInd <= halfwayCutoff]<br><br>        measuredK = np.zeros([dim1**3], dtype=complex)<br><br>        # accumulate the sums<br>        vals_real = np.bincount(masterInd, weights=(masterDistances * np.real(masterVals)))<br>        vals_cx = np.bincount(masterInd, weights=(masterDistances * np.imag(masterVals)))<br>        vals = vals_real + 1j * vals_cx<br>        sum_weights = np.bincount(masterInd, weights=(masterDistances))<br>        vals[sum_weights != 0] = vals[sum_weights != 0] / sum_weights[sum_weights != 0]<br>        measuredK[np.arange(np.size(vals))] = vals<br>        measuredK = np.reshape(measuredK,[dim1,dim1,dim1],order='F')<br><br>        measuredK[np.isnan(measuredK)] = 0<br><br>        <font color="orange">if </font>enforce_resolution_circle:<br>            Q = <b><font color="orange">GENFIRE</font></b>.utility.generateKspaceIndices(measuredK)<br>            measuredK[Q>1] = 0<br><br>        # apply Hermitian symmetry<br>        measuredK = <b><font color="orange">GENFIRE</font></b>.utility.hermitianSymmetrize(measuredK)<br><br>        print ("Fourier grid assembled in {0:0.1f} seconds".format(time.time()-tic))<br>        return measuredK<br><br><br><br>    <font color="orange">def </font>fillInFourierGrid_DFT(projections,angles,interpolationCutoffDistance, enforce_resolution_circle):<br>        """<br>        * fillInFourierGrid_DFT *<br><br>        DFT gridding function for converting a set of 2D projection images into a 3D Fourier grid<br><br>        :param projections: N x N x num_projections NumPy array containing the projections<br>        :param angles: 3 x num_projections NumPy array of Euler angles phi,theta, psi<br>        :param interpolationCutoffDistance: Radius of interpolation kernel. Only values within this radius of a grid point are considered<br>        :param enforce_resolution_circle: boolean; whether or not to truncate reciprocal space to Nyquist frequency<br>        :return: the assembled Fourier grid<br><br><br>        Author: Yongsoo Yang<br>        Transcribed from MATLAB codes by Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of California, Los Angeles<br>        Copyright 2015-2016. All rights reserved.<br>        """<br><br><br>        print ("Assembling Fourier grid.")<br>        tic = time.time()<br>        <font color="orange">from </font><b><font color="orange">GENFIRE</font></b>.utility <font color="orange">import </font>pointToPlaneClosest, pointToPlaneDistance<br>        (n1, n2) = (np.shape(projections)[0],np.shape(projections)[1])<br>        minInvThresh = 0.00001<br>        num_projections = np.shape(projections)[2]<br>        normVECs = np.zeros((num_projections,3))<br>        rotMATs  = np.zeros((3,3,num_projections))<br>        phis     = angles[:, 0] * PI/180<br>        thetas   = angles[:, 1] * PI/180<br>        psis     = angles[:, 2] * PI/180<br>        init_normvec = np.array([0, 0, 1],dtype=float)<br>        <font color="orange">for </font>ang_num in range(num_projections):<br>            phi   = phis[ang_num]<br>            theta = thetas[ang_num]<br>            psi   = psis[ang_num]<br>            R     = np.array([[np.cos(psi)*np.cos(theta)*np.cos(phi)-np.sin(psi)*np.sin(phi) ,np.cos(psi)*np.cos(theta)*np.sin(phi)+np.sin(psi)*np.cos(phi)   ,    -np.cos(psi)*np.sin(theta)],<br>            [-np.sin(psi)*np.cos(theta)*np.cos(phi)-np.cos(psi)*np.sin(phi), -np.sin(psi)*np.cos(theta)*np.sin(phi)+np.cos(psi)*np.cos(phi) ,   np.sin(psi)*np.sin(theta) ],<br>            [np.sin(theta)*np.cos(phi)                               , np.sin(theta)*np.sin(phi)                                ,              np.cos(theta)]])<br>            rotMATs[:, :, ang_num] = R.T<br>            normVECs[ang_num, :] = np.dot(R.T, init_normvec.T)<br>        k1               = np.arange(-1*(n1//2), 1, 1, dtype=float)<br>        k1_full          = np.arange(-1*(n1//2), n1//2 + 1, 1, dtype=float)<br>        k2               = np.arange(-1 * n2//2, n2//2 + 1, 1, dtype=float)<br>        k3               = np.arange(-1 * n1//2, n1//2 + 1, 1, dtype=float)<br>        (null, K1, null) = np.meshgrid(k2, k1, k3)<br>        FS               = np.zeros_like(K1, dtype=complex)<br>        Numpt            = np.zeros_like(K1)<br>        invSumTotWeight  = np.zeros_like(K1, dtype=float)<br>        [K20, K10] = np.meshgrid(k2[:-1],k1_full[:-1])<br>        K20 = K20.flatten()<br>        K10 = K10.flatten()<br>        try:<br>            artifical_error = 1/0 # This loop uses broadcasting, which can use more memory, so there is a try/catch as a failsafe. However<br>            # the simple loop seems to be faster, so for the moment I have just introduced an error artificially as a lazy way of leaving both implementations<br>            <font color="orange">for </font>proj_num in range(num_projections):<br>                curr_proj = projections[:, :, proj_num].flatten()<br>                [K2, K1, K3] = np.meshgrid(k2,k1,k3)<br>                D = pointToPlaneDistance(np.vstack((K1.flatten(order="F"), K2.flatten(order="F"), K3.flatten(order="F"))).T, normVECs[proj_num,:])<br>                Dind = np.array(np.where(D < interpolationCutoffDistance))<br>                CP = pointToPlaneClosest(np.vstack((K1.flatten(order="F")[[Dind]], K2.flatten(order="F")[[Dind]], K3.flatten(order="F")[[Dind]])).T, normVECs[proj_num,:].T,np.zeros(np.size(Dind),dtype=float))<br>                CP_plane = np.dot(np.linalg.inv(rotMATs[:, :, proj_num]), CP.T)<br><br>                Gind = Dind[0,(abs(CP_plane[0,:]) <= n1/2) & (abs(CP_plane[1,:]) <= n2/2)]<br>                G_CP_plane = CP_plane[:,( abs(CP_plane[0,:]) <= n1/2 )& (abs(CP_plane[1,:]) <= n2/2) ]<br>                nonzero_ind = np.where(curr_proj!=0)<br>                X = np.zeros((np.shape(G_CP_plane)[1], 1), dtype=float)<br>                Y = np.zeros((np.shape(G_CP_plane)[1], 1), dtype=float)<br>                X[:, 0] = G_CP_plane[0, :]<br>                Y[:, 0] = G_CP_plane[1, :]<br><br>                Fpoints = np.sum( curr_proj[nonzero_ind] * np.exp( -1j*2*PI * (K10[nonzero_ind] * X / n1 + K20[nonzero_ind] * Y / n2  ) ) ,axis=1)<br>                distances = D[Gind]<br>                distances[ distances < minInvThresh ] = minInvThresh<br>                currTotWeight = 1 / distances<br>                Gind = np.unravel_index(Gind, np.shape(FS), order="F")<br>                FS[Gind] = FS[Gind] * invSumTotWeight[Gind] + currTotWeight * Fpoints<br>                invSumTotWeight[Gind] = invSumTotWeight[Gind] + currTotWeight<br>                FS[Gind] = FS[Gind] / invSumTotWeight[Gind]<br>                Numpt[Gind] = Numpt[Gind] + 1<br>        except:<br>            <font color="orange">for </font>proj_num in range(num_projections):<br>                curr_proj = projections[:, :, proj_num].flatten()<br>                [K2, K1, K3] = np.meshgrid(k2,k1,k3)<br>                D = pointToPlaneDistance(np.vstack((K1.flatten(order="F"), K2.flatten(order="F"), K3.flatten(order="F"))).T, normVECs[proj_num,:])<br>                Dind = np.array(np.where(D < interpolationCutoffDistance))<br>                CP = pointToPlaneClosest(np.vstack((K1.flatten(order="F")[[Dind]], K2.flatten(order="F")[[Dind]], K3.flatten(order="F")[[Dind]])).T, normVECs[proj_num,:].T,np.zeros(np.size(Dind),dtype=float))<br>                CP_plane = np.dot(np.linalg.inv(rotMATs[:, :, proj_num]), CP.T)<br><br>                Gind = Dind[0,(abs(CP_plane[0,:]) <= n1/2) & (abs(CP_plane[1,:]) <= n2/2)]<br>                G_CP_plane = CP_plane[:,( abs(CP_plane[0,:]) <= n1/2 )& (abs(CP_plane[1,:]) <= n2/2) ]<br>                Fpoints = np.zeros(np.shape(G_CP_plane)[1], dtype=complex)<br><br>                nonzero_ind = np.where(curr_proj!=0)<br>                # for i,v in enumerate(G_CP_plane.T):<br>                #     Fpoints[i] = np.sum( curr_proj[nonzero_ind] * np.exp( -1j*2*PI * (K10[nonzero_ind] * v[0] / n1 + K20[nonzero_ind] * v[1] / n2  ) ) )<br><br><br>                K10_t = K10[nonzero_ind]<br>                K20_t = K20[nonzero_ind]<br>                curr_proj = curr_proj[nonzero_ind]<br><br>                <font color="orange">for </font>i in range(np.shape(G_CP_plane)[1]):<br>                    Fpoints[i] = np.sum( curr_proj * np.exp( -1j*2*PI * (K10_t * G_CP_plane[0, i] / n1 + K20_t * G_CP_plane[1, i] / n2  ) ) )<br>                    # Fpoints[i] = np.sum( curr_proj[nonzero_ind] * np.exp( -1j*2*PI * (K10[nonzero_ind] * G_CP_plane[0, i] / n1 + K20[nonzero_ind] * G_CP_plane[1, i] / n2  ) ) )<br>                distances = D[Gind]<br>                distances[ distances < minInvThresh ] = minInvThresh<br>                currTotWeight = 1 / distances<br>                Gind = np.unravel_index(Gind, np.shape(FS), order="F")<br>                FS[Gind] = FS[Gind] * invSumTotWeight[Gind] + currTotWeight * Fpoints<br>                invSumTotWeight[Gind] = invSumTotWeight[Gind] + currTotWeight<br>                FS[Gind] = FS[Gind] / invSumTotWeight[Gind]<br>                Numpt[Gind] = Numpt[Gind] + 1<br>        # measuredK = np.zeros((n1,n2,n1), dtype=complex)<br>        measuredK = np.zeros((n1+1,n2+1,n1+1), dtype=complex)<br>        measuredK[:n1//2 + 1, :, :] = FS[:, :, :]<br>        print ("Fourier grid assembled in {0:0.1f} seconds".format(time.time()-tic))<br><br>        <font color="orange">if </font>enforce_resolution_circle:<br>            Q = <b><font color="orange">GENFIRE</font></b>.utility.generateKspaceIndices(measuredK)<br>            measuredK[Q>1] = 0<br><br>        return <b><font color="orange">GENFIRE</font></b>.utility.hermitianSymmetrize(measuredK)[:-1,:-1,:-1]<br><br>    <font color="orange">def </font>readMAT(filename):<br>        """<br>        * readMAT *<br><br>        Read projections from a .mat file<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of California, Los Angeles<br>        Copyright 2015-2016. All rights reserved.<br><br>        :param filename: MATLAB file (.mat) containing projections<br>        :return: NumPy array containing projections<br>        """<br><br>        try: #try to open the projections as a stack<br>            projections = scipy.io.loadmat(filename)<br>            projections = np.array(projections[projections.keys()[0]])<br>        except: ##<br>             #check if the projections are in individual files<br>            flag = <font color="orange">True<br></font>            filename_base, file_extension = os.path.splitext(filename)<br>            projectionCount = 1<br>            <font color="orange">while </font>flag: #first count the number of projections so the array can be initialized<br>                projectionCount = projectionCount<br>                nextFile = filename_base + str(projectionCount) + file_extension<br>                <font color="orange">if </font>os.path.isfile(nextFile):<br>                    projectionCount += 1<br>                else:<br>                    flag = <font color="orange">False<br></font><br><br>            ## open first projection to get dimensions<br>            pj = scipy.io.loadmat(filename_base + str(1) + file_extension)<br>            pj = pj[projections.keys()[0]]<br>            dims = np.shape(pj)<br>            #initialize projection array<br>            projections = np.zeros((dims[0], dims[1], projectionCount),dtype=int)<br><br>            #now actually load in the tiff images<br>            <font color="orange">for </font>projNum in range(projectionCount):<br>                nextFile = filename_base + str(projNum) + file_extension<br>                pj = scipy.io.loadmat(filename_base + str(projNum) + file_extension)<br>                pj = pj[pj.keys()[0]]<br>                projections[:, :, projNum] = np.array(pj)<br><br>        return projections<br><br><br>    <font color="orange">def </font>readTIFF(filename):<br>        """<br>        * readTIFF *<br><br>        Read (possibly multiple) TIFF images into a NumPy array<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of California, Los Angeles<br>        Copyright 2015-2016. All rights reserved.<br><br>        :param filename: Name of TIFF file or TIFF file basename to read. If the filename is a base then<br>        #       the images must begin with the string contained in filename followed by consecutive integers with<br>        #       no zero padding, i.e. foo1.tiff, foo2.tiff,..., foo275.tiff<br>        :return: NumPy array containing projections<br>        """<br>        <font color="orange">import </font>functools<br>        <font color="orange">from </font>PIL <font color="orange">import </font>Image<br>        <font color="orange">import </font>os<br>        try:<br>            projections = np.array(Image.open(filename))<br>        except:<br>            flag = <font color="orange">True<br></font>            filename_base, file_extension = os.path.splitext(filename)<br>            projectionCount = 1<br>            <font color="orange">while </font>flag: #first count the number of projections so the array can be initialized<br>                projectionCount = projectionCount<br>                nextFile = filename_base + str(projectionCount) + file_extension<br>                <font color="orange">if </font>os.path.isfile(nextFile):<br>                    projectionCount += 1<br>                else:<br>                    flag = <font color="orange">False<br></font><br>            ## open first projection to get dimensions<br>            dims = np.shape(Image.open(filename_base + str(1) + file_extension))<br><br>            #initialize projection array<br>            projections = np.zeros((dims[0], dims[1], projectionCount),dtype=int)<br><br>            pool = Pool(4)<br>            func = functools.partial(readInTiffProjection, filename_base)<br>            pj = pool.map(func, range(projectionCount))<br>            <font color="orange">for </font>j  in range(projectionCount):<br>                projections[:, :, j] = pj[j]<br>            return projections<br><br>    <font color="orange">def </font>readInTiffProjection(filename_base, fileNumber):<br>        """<br>        * readInTiffProjection *<br><br>        Reads and returns a single TIFF image as a NumPy array<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of California, Los Angeles<br>        Copyright 2015-2016. All rights reserved.<br><br>        :param filename_base: Base filename of TIFF<br>        :param fileNumber: Image number<br>        :return: Image in a 2D NumPy array<br>        """<br>        <font color="orange">from </font>PIL <font color="orange">import </font>Image<br>        nextFile = filename_base + str(fileNumber) + '.tif'<br>        return np.array(Image.open(nextFile))<br><br>    <font color="orange">def </font>readMRC(filename, dtype=float,order="C"):<br>        """<br>        * readMRC *<br><br>        Read in a volume in .mrc file format. See http://bio3d.colorado.edu/imod/doc/mrc_format.txt<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of California, Los Angeles<br>        Copyright 2015-2016. All rights reserved.<br><br>        :param filename: Filename of .mrc<br>        :return: NumPy array containing the .mrc data<br>        """<br>        <font color="orange">import </font>struct<br>        headerIntNumber = 56<br>        sizeof_int = 4<br>        headerCharNumber = 800<br>        sizeof_char = 1<br>        <font color="orange">with </font>open(filename,'rb') as fid:<br>            int_header = struct.unpack('=' + 'i'*headerIntNumber, fid.read(headerIntNumber * sizeof_int))<br>            char_header = struct.unpack('=' + 'c'*headerCharNumber, fid.read(headerCharNumber * sizeof_char))<br>            dimx, dimy, dimz, data_flag= int_header[:4]<br>            <font color="orange">if </font>(data_flag == 0):<br>                datatype='u1'<br>            <font color="orange">el<font color="orange">if </font></font>(data_flag ==1):<br>                datatype='i1'<br>            <font color="orange">el<font color="orange">if </font></font>(data_flag ==2):<br>                datatype='f4'<br>            <font color="orange">el<font color="orange">if </font></font>(data_flag ==3):<br>                datatype='c'<br>            <font color="orange">el<font color="orange">if </font></font>(data_flag ==4):<br>                datatype='f4'<br>            <font color="orange">el<font color="orange">if </font></font>(data_flag ==6):<br>                datatype='u2'<br>            else:<br>                raise ValueError("No supported datatype found!\n")<br>            return np.fromfile(file=fid, dtype=datatype,count=dimx*dimy*dimz).reshape((dimx,dimy,dimz),order=order).astype(dtype)<br><br>    <font color="orange">def </font>writeMRC(filename, arr, datatype='f4'):<br>        """<br>        * writeMRC *<br><br>        Write a volume to .mrc file format. See http://bio3d.colorado.edu/imod/doc/mrc_format.txt<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of California, Los Angeles<br>        Copyright 2015-2016. All rights reserved<br><br>        :param filename: Filename of .mrc file to write<br>        :param arr: NumPy volume of data to write<br>        :param dtype: Type of data to write<br>        """<br>        dimx, dimy, dimz = np.shape(arr)<br>        <font color="orange">if </font>datatype != arr.dtype:<br>            arr = arr.astype(datatype)<br>        int_header = np.zeros(56,dtype='int32')<br><br>        <font color="orange">if </font>(datatype == 'u1'):<br>            data_flag = 0<br>        <font color="orange">el<font color="orange">if </font></font>(datatype =='i1'):<br>            data_flag = 1<br>        <font color="orange">el<font color="orange">if </font></font>(datatype =='f4'):<br>            data_flag = 2<br>        <font color="orange">el<font color="orange">if </font></font>(datatype =='c'):<br>            data_flag = 3<br>        <font color="orange">el<font color="orange">if </font></font>(datatype =='f4'):<br>            data_flag = 4<br>        <font color="orange">el<font color="orange">if </font></font>(datatype =='u2'):<br>            data_flag = 6<br>        else:<br>            raise ValueError("No supported datatype found!\n")<br><br>        int_header[:4] = (dimx,dimy,dimz,data_flag)<br>        char_header = str(' '*800)<br>        <font color="orange">with </font>open(filename,'wb') as fid:<br>            fid.write(int_header.tobytes())<br>            fid.write(char_header)<br>            fid.write(arr.tobytes())<br><br><br><br>    <font color="orange">class </font>DisplayFigure:<br>        """<br>        * DisplayFigure *<br><br>        Helper class for displaying figures during reconstruction process<br><br>        Author: Alan (AJ) Pryor, Jr.<br>        Jianwei (John) Miao Coherent Imaging Group<br>        University of California, Los Angeles<br>        Copyright 2015-2016. All rights reserved.<br>        """<br>        <font color="orange">def </font>__init__(self):<br>            <font color="orange">self.</font>DisplayFigureON = <font color="orange">False<br></font>            <font color="orange">self.</font>DisplayErrorFigureON = <font color="orange">False<br></font>            <font color="orange">self.</font>displayFrequency = 5<br>            <font color="orange">self.</font>reconstructionDisplayWindowSize = 0<br><br><br><font color="orange">def </font>toString(string):<br>    try:<br>        <font color="orange">import </font><b><font color="orange">GENFIRE</font></b>.g<font color="orange">ui.</font>utility<br>        return <b><font color="orange">GENFIRE</font></b>.g<font color="orange">ui.</font>utility.toString(string)<br>    except ImportError:<br>        return str(string)<br><br><font color="orange">class </font>ReconstructionParameters():<br><br>    """<br>    Helper class for containing reconstruction parameters<br>    """<br>    _supportedFiletypes = ['.tif', '.mrc', '.mat', '.npy']<br>    _supportedAngleFiletypes = ['.txt', '.mat', '.npy']<br>    <font color="orange">def </font>__init__(self):<br>        <font color="orange">self.</font>projectionFilename                  = ""<br>        <font color="orange">self.</font>angleFilename                       = ""<br>        <font color="orange">self.</font>supportFilename                     = ""<br>        <font color="orange">self.</font>resolutionExtensionSuppressionState = 1 #1 for resolution extension/suppression, 2 for off, 3 for just extension<br>        <font color="orange">self.</font>numIterations                       = 100<br>        <font color="orange">self.</font>displayFigure                       = DisplayFigure()<br>        <font color="orange">self.</font>oversamplingRatio                   = 3<br>        <font color="orange">self.</font>interpolationCutoffDistance         = 0.7<br>        <font color="orange">self.</font>isInitialObjectDefined              = <font color="orange">False<br></font>        <font color="orange">self.</font>resultsFilename                     = os.path.join(os.getcwd(), 'results.mrc')<br>        <font color="orange">self.</font>useDefaultSupport                   = <font color="orange">True<br></font>        <font color="orange">self.</font>calculateRfree                      = <font color="orange">True<br></font>        <font color="orange">self.</font>initialObjectFilename               = None<br>        <font color="orange">self.</font>constraint_positivity               = <font color="orange">True<br></font>        <font color="orange">self.</font>constraint_support                  = <font color="orange">True<br></font>        <font color="orange">self.</font>griddingMethod                      = "FFT"<br>        <font color="orange">self.</font>enforceResolutionCircle             = <font color="orange">True<br></font>        <font color="orange">self.</font>permitMultipleGridding              = <font color="orange">True<br></font><br>    <font color="orange">def </font>checkParameters(self): #verify file extensions are supported<br>        <font color="orange">import </font>os<br>        parametersAreGood = 1<br><br>        projection_extension = os.path.splitext(<font color="orange">self.</font>projectionFilename)<br>        <font color="orange">if </font>projection_extension[1] not in ReconstructionParameters._supportedFiletypes \<br>                or not os.path.isfile(<font color="orange">self.</font>projectionFilename):<br>            parametersAreGood = 0<br><br>        angle_extension = os.path.splitext(<font color="orange">self.</font>angleFilename)<br>        <font color="orange">if </font>angle_extension[1] not in ReconstructionParameters._supportedAngleFiletypes \<br>                or not os.path.isfile(<font color="orange">self.</font>angleFilename):<br>            parametersAreGood = 0<br><br>        <font color="orange">if </font>not <font color="orange">self.</font>useDefaultSupport:<br>            <font color="orange">if </font><font color="orange">self.</font>supportFilename != "": #empty support filename is okay, as this will trigger generation of a default support<br>                support_extension = os.path.splitext(<font color="orange">self.</font>supportFilename)<br>                <font color="orange">if </font>support_extension[1] not in ReconstructionParameters._supportedFiletypes \<br>                        or not os.path.isfile(<font color="orange">self.</font>supportFilename):<br>                    parametersAreGood = 0<br><br>        <font color="orange">if </font>not <font color="orange">self.</font>getResultsFilename():<br>            parametersAreGood = 0<br>        return parametersAreGood<br><br>    # Define setters/getters. It's not very pythonic to do so, but  I came from C++ and wrote<br>    # this before I knew better. In any case it doesn't affect much.<br><br>    <font color="orange">def </font>setProjectionFilename(self, projectionFilename):<br>        <font color="orange">if </font>projectionFilename:<br>            <font color="orange">self.</font>projectionFilename = os.path.join(os.getcwd(), toString(projectionFilename))<br><br>    <font color="orange">def </font>getProjectionFilename(self):<br>        return <font color="orange">self.</font>projectionFilename<br><br>    <font color="orange">def </font>setAngleFilename(self, angleFilename):<br>        <font color="orange">if </font>angleFilename:<br>            <font color="orange">self.</font>angleFilename = os.path.join(os.getcwd(), toString(angleFilename))<br><br>    <font color="orange">def </font>getAngleFilename(self):<br>        return <font color="orange">self.</font>angleFilename<br><br>    <font color="orange">def </font>setSupportFilename(self, supportFilename):<br>        <font color="orange">if </font>supportFilename:<br>            <font color="orange">self.</font>supportFilename = os.path.join(os.getcwd(), toString(supportFilename))<br><br>    <font color="orange">def </font>getSupportFilename(self):<br>        return <font color="orange">self.</font>supportFilename<br><br>    <font color="orange">def </font>setResultsFilename(self, resultsFilename):<br>        <font color="orange">if </font>resultsFilename:<br>            <font color="orange">self.</font>resultsFilename = os.path.join(os.getcwd(), toString(resultsFilename))<br><br>    <font color="orange">def </font>getResultsFilename(self):<br>        return <font color="orange">self.</font>resultsFilename<br><br><br>    <font color="orange">def </font>setInitialObjectFilename(self, initialObjectFilename):<br>        <font color="orange">self.</font>initialObjectFilename = os.path.join(os.getcwd(), toString(initialObjectFilename))<br>        <font color="orange">self.</font>isInitialObjectDefined = <font color="orange">True<br></font><br>    <font color="orange">def </font>getInitialObjectFilename(self):<br>        <font color="orange">if </font><font color="orange">self.</font>CheckIfInitialObjectIsDefined():<br>            return <font color="orange">self.</font>initialObjectFilename<br>        else:<br>            pass<br><br>    <font color="orange">def </font>CheckIfInitialObjectIsDefined(self):<br>        return <font color="orange">self.</font>isInitialObjectDefined<br><br>    <font color="orange">def </font>setResolutionExtensionSuppressionState(self, state):<br>        <font color="orange">self.</font>resolutionExtensionSuppressionState = state<br><br>    <font color="orange">def </font>getResolutionExtensionSuppressionState(self):<br>        return <font color="orange">self.</font>resolutionExtensionSuppressionState<br><br>    <font color="orange">def </font>setNumberOfIterations(self,numIterations):<br>        <font color="orange">self.</font>numIterations = numIterations<br><br>    <font color="orange">def </font>getNumberOfIterations(self):<br>        return <font color="orange">self.</font>numIterations<br><br>    <font color="orange">def </font>toggleDisplayFigure(self): # whether or not to display figure during reconstruction<br>        <font color="orange">if </font><font color="orange">self.</font>displayFigure.DisplayFigureON:<br>            <font color="orange">self.</font>displayFigure.DisplayFigureON = <font color="orange">False<br></font>        else:<br>            <font color="orange">self.</font>displayFigure.DisplayFigureON = <font color="orange">True<br></font><br>        <font color="orange">if </font><font color="orange">self.</font>displayFigure.DisplayErrorFigureON:<br>            <font color="orange">self.</font>displayFigure.DisplayErrorFigureON = <font color="orange">False<br></font>        else:<br>            <font color="orange">self.</font>displayFigure.DisplayErrorFigureON = <font color="orange">True<br></font><br>    <font color="orange">def </font>getDisplayFigure(self):<br>        return <font color="orange">self.</font>displayFigure<br><br>    <font color="orange">def </font>setOversamplingRatio(self, oversamplingRatio):<br>        <font color="orange">self.</font>oversamplingRatio = int(oversamplingRatio)<br><br>    <font color="orange">def </font>getOversamplingRatio(self):<br>        return <font color="orange">self.</font>oversamplingRatio<br><br>    <font color="orange">def </font>setInterpolationCutoffDistance(self, interpolationCutoffDistance):<br>        <font color="orange">self.</font>interpolationCutoffDistance = float(interpolationCutoffDistance)<br><br>    <font color="orange">def </font>getInterpolationCutoffDistance(self):<br>        return <font color="orange">self.</font>interpolationCutoffDistance<br></code></body>
    </html>