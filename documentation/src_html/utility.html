<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>..//GENFIRE/utility</title>
  <meta name="description" content="GENFIRE Documentation">
  <meta name="author" content="Alan (AJ) Pryor, Jr.">  <link rel="stylesheet" href="css/styles.css?v=1.0">
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
<code>"""<br>* GENFIRE.utility *<br><br>This module contains various useful functions that do not fit into another category<br><br><br>Author: Alan (AJ) Pryor, Jr.<br>Jianwei (John) Miao Coherent Imaging Group<br>University of California, Los Angeles<br>Copyright 2015-2016. All rights reserved.<br>"""<br><br><br><font color="orange">from </font>__future__ <font color="orange">import </font>division<br><font color="orange">import </font>numpy as np<br><font color="orange">from </font>scipy.interpolate <font color="orange">import </font>RegularGridInterpolator<br>PI = np.pi<br><br>try:<br>    <font color="orange">import </font>pyfftw<br><br>    #These are just wrappers around various flavors of the FFT<br>    <font color="orange">def </font>rfftn(arr, threads=6):<br>        return pyfftw.interfaces.numpy_fft.rfftn(arr,overwrite_input=True,threads=threads)<br>    <font color="orange">def </font>irfftn(arr, threads=6):<br>        return pyfftw.interfaces.numpy_fft.irfftn(arr,overwrite_input=True,threads=threads)<br>    <font color="orange">def </font>rfftn_fftshift(arr, threads=6):<br>        return pyfftw.interfaces.numpy_fft.fftshift(pyfftw.interfaces.numpy_fft.rfftn(pyfftw.interfaces.numpy_fft.ifftshift(arr),overwrite_input=True,threads=threads))<br>    <font color="orange">def </font>irfftn_fftshift(arr, threads=6):<br>        return pyfftw.interfaces.numpy_fft.fftshift(pyfftw.interfaces.numpy_fft.irfftn(pyfftw.interfaces.numpy_fft.ifftshift(arr),overwrite_input=True,threads=threads))<br>    <font color="orange">def </font>fftn(arr, threads=6):<br>        return pyfftw.interfaces.numpy_fft.fftn(arr,overwrite_input=True,threads=threads)<br>    <font color="orange">def </font>ifftn(arr, threads=6):<br>        return pyfftw.interfaces.numpy_fft.ifftn(arr,overwrite_input=True,threads=threads)<br>    <font color="orange">def </font>fftn_fftshift(arr, threads=6):<br>        return pyfftw.interfaces.numpy_fft.fftshift(pyfftw.interfaces.numpy_fft.fftn(pyfftw.interfaces.numpy_fft.ifftshift(arr),overwrite_input=True,threads=threads))<br>    <font color="orange">def </font>ifftn_fftshift(arr, threads=6):<br>        return pyfftw.interfaces.numpy_fft.fftshift(pyfftw.interfaces.numpy_fft.ifftn(pyfftw.interfaces.numpy_fft.ifftshift(arr),overwrite_input=True,threads=threads))<br><br>except ImportError:<br>    print("No pyFFTW installation found. Continuing <font color="orange">with </font>NumPy FFT")<br>    <font color="orange">import </font>numpy as np<br>    <font color="orange">def </font>rfftn(arr):<br>        return np.fft.rfftn(arr)<br>    <font color="orange">def </font>irfftn(arr):<br>        return np.fft.irfftn(arr)<br>    <font color="orange">def </font>rfftn_fftshift(arr):<br>        return np.fft.fftshift(np.fft.rfftn(np.fft.ifftshift(arr)))<br>    <font color="orange">def </font>irfftn_fftshift(arr):<br>        return np.fft.fftshift(np.fft.irfftn(np.fft.ifftshift(arr)))<br>    <font color="orange">def </font>fftn(arr):<br>        return np.fft.fftn(arr)<br>    <font color="orange">def </font>ifftn(arr):<br>        return np.fft.ifftn(arr)<br>    <font color="orange">def </font>fftn_fftshift(arr):<br>        return np.fft.fftshift(np.fft.fftn(np.fft.ifftshift(arr)))<br>    <font color="orange">def </font>ifftn_fftshift(arr):<br>        return np.fft.fftshift(np.fft.ifftn(np.fft.ifftshift(arr)))<br><br><br><font color="orange">def </font>hermitianSymmetrize(volume):<br>    """<br>    * hermitianSymmetrize *<br><br>    Enforce Hermitian symmetry to volume<br><br>    :param volume: 3D volume to symmetrize<br>    :return: symmetrized volume<br>    <br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright (c) 2016. All Rights Reserved.<br>    """<br><br>    startDims = np.shape(volume) # initial dimensions<br><br>    # remember the initial dimensions for the end<br>    dimx = startDims[0]<br>    dimy = startDims[1]<br>    dimz = startDims[2]<br>    flag = <font color="orange">False </font># flag to trigger copying to new odd dimensioned array<br><br>    #check if any dimension is odd<br>    <font color="orange">if </font>dimx % 2 == 0:<br>        dimx += 1<br>        flag = <font color="orange">True<br></font><br>    <font color="orange">if </font>dimy % 2 == 0:<br>        dimy += 1<br>        flag = <font color="orange">True<br></font><br>    <font color="orange">if </font>dimz % 2 == 0:<br>        dimz += 1<br>        flag = <font color="orange">True<br></font><br>    <font color="orange">if </font>flag: # if any dimensions are even, create a new with all odd dimensions and copy volume<br>        newInput = np.zeros((dimx,dimy,dimz), dtype=complex) #new array<br>        newInput[:startDims[0], :startDims[1], :startDims[2]] = volume # copy values<br>        numberOfValues = (newInput != 0).astype(float) #track number of values for averaging<br>        newInput = newInput + np.conj(newInput[::-1, ::-1, ::-1]) # combine Hermitian symmetry mates<br>        numberOfValues = numberOfValues + numberOfValues[::-1, ::-1, ::-1] # track number of points included in each sum<br><br>        newInput[numberOfValues != 0] /= numberOfValues[numberOfValues != 0] # take average where two values existed<br>        newInput[np.isnan(newInput)] = 0 # Shouldn't be any nan, but just to be safe<br><br>        return newInput[:startDims[0], :startDims[1], :startDims[2]] # return original dimensions<br><br><br>    else: # otherwise, save yourself the trouble of copying the matrix over. See previous comments for line-by-line<br>        numberOfValues = (volume != 0).astype(float)<br>        volume = volume + np.conjugate(volume[::-1, ::-1, ::-1])<br>        numberOfValues = numberOfValues + numberOfValues[::-1, ::-1, ::-1]<br>        volume[numberOfValues != 0] /= numberOfValues[numberOfValues != 0]<br>        volume[np.isnan(volume)] = 0<br>        return volume<br><br><br><font color="orange">def </font>smooth3D(object,resolutionCutoff):<br>    """<br>    * smooth3D *<br><br>    Low pass filter a 3D volume<br><br>    :param object: 3D volume<br>    :param resolutionCutoff: Fraction of Nyquist frequency to use as sigma for the Gaussian filter<br>    :return: smoothed volume<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright (c) 2016. All Rights Reserved.<br>    """<br>    dims = np.shape(object)<br>    <font color="orange">if </font>dims[2] == 1:<br>        raise Exception('This is not a 3D object, use smooth2D instead.')<br>    Xcenter = round(dims[0]//2)<br>    Ycenter = round(dims[1]//2)<br>    Zcenter = round(dims[2]//2)<br><br>    # These  next few lines are easier to read, but in the actual code I just directly<br>    # place the np.arange terms in to avoid creating unnecessary variables<br>    # Xvec = np.arange(0,dims[0])-Xcenter<br>    # Yvec = np.arange(0,dims[1])-Ycenter<br>    # Zvec = np.arange(0,dims[2])-Zcenter<br>    # xx, yy, zz = np.meshgrid(Xvec, Yvec, Zvec)<br><br>    xx, yy, zz = np.meshgrid(np.arange(0,dims[0])-Xcenter, np.arange(0,dims[1])-Ycenter, np.arange(0,dims[2])-Zcenter)<br>    sigma  = dims[0]/2*resolutionCutoff<br><br>    #construct the filter and normalize<br>    K_filter = np.exp(-(((xx)**2 + (yy)**2 + (zz) **2)/(2*sigma*sigma)))<br>    K_filter /= np.max(np.max(np.max(abs(K_filter))))<br><br>    # take FFT and multiply by filter<br>    # kbinned = pyfftw.interfaces.numpy_fft.fftshift(pyfftw.interfaces.numpy_fft.fftn(object,overwrite_input=True)) * K_filter<br>    kbinned = fftn_fftshift(object) * K_filter<br><br>    # Assuming the input is real, the output will be approximately real, but will have some<br>    # tiny imaginary part due to rounding errors. This function would work for smoothing a<br>    # complex object, but this return statement would need to be modified<br>    # return np.real(pyfftw.interfaces.numpy_fft.ifftn(pyfftw.interfaces.numpy_fft.ifftshift(kbinned)))<br>    return np.real(fftn_fftshift(kbinned))<br><br><br><br><font color="orange">def </font>smooth2D(object,resolutionCutoff):<br>    """<br>    * smooth2D *<br><br>    Low pass filter a 2D image<br><br>    :param object: 2D image<br>    :param resolutionCutoff: Fraction of Nyquist frequency to use as sigma for the Gaussian filter<br>    :return: smoothed image<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright (c) 2016. All Rights Reserved.<br>    """<br>    dims = np.shape(object)<br>    <font color="orange">if </font>len(dims)>2:<br>        raise Exception('This is a 3D object, use smooth3D instead.')<br>    Xcenter = round(dims[0]//2)<br>    Ycenter = round(dims[1]//2)<br><br>    # These  next few lines are easier to read, but in the actual code I just directly<br>    # place the np.arange terms in to avoid creating unnecessary variables<br>    # Xvec = np.arange(0,dims[0])-Xcenter<br>    # Yvec = np.arange(0,dims[1])-Ycenter<br>    # xx, yy = np.meshgrid(Xvec, Yvec)<br><br>    xx, yy = np.meshgrid(np.arange(0,dims[0])-Xcenter, np.arange(0,dims[1])-Ycenter)<br>    sigma  = dims[0]/2*resolutionCutoff<br><br>    #construct the filter and normalize<br>    K_filter = np.exp(-(((xx)**2 + (yy)**2)/(2*sigma*sigma)))<br>    K_filter /= np.max(np.max(np.max(abs(K_filter))))<br><br>    # take FFT and multiply by filter<br>    # kbinned =  pyfftw.interfaces.numpy_fft.fftshift(pyfftw.interfaces.numpy_fft.fftn(object,overwrite_input=True)) * K_filter<br>    kbinned = fftn_fftshift(object) * K_filter<br>    # Assuming the input is real, the output will be approximately real, but will have some<br>    # tiny imaginary part due to rounding errors. This function would work for smoothing a<br>    # complex object, but this return statement would need to be modified<br>    # return np.real(pyfftw.interfaces.numpy_fft.ifftn(pyfftw.interfaces.numpy_fft.ifftshift(kbinned)))<br>    return np.real(ifftn_fftshift(kbinned))<br><br><br><font color="orange">def </font>calculateProjection_interp(modelK, phi, theta, psi):<br>    """<br>    * calculateProjection_interp *<br><br>    Calculate a projection of a 3D volume from it's oversampled Fourier transform by interpolating<br>    the central slice at the orientation determined by Euler angles (phi, theta, psi)<br><br>    :param modelK: numpy array holding the oversampled FFT of the model<br>    :param phi: euler angle 1<br>    :param theta: euler angle 2<br>    :param psi: euler angle 3<br>    :return: projection<br>    """<br><br>    # get dimensions<br>    dims = np.shape(modelK)<br>    Xcenter = round(dims[0]//2)<br>    Ycenter = round(dims[1]//2)<br>    Zcenter = round(dims[2]//2)<br><br>    # convert angles to radians<br>    phi *= PI/180<br>    theta *= PI/180<br>    psi *= PI/180<br><br>    # construct rotation matrix<br>    R = np.array([[np.cos(psi)*np.cos(theta)*np.cos(phi)-np.sin(psi)*np.sin(phi) , np.cos(psi)*np.cos(theta)*np.sin(phi)+np.sin(psi)*np.cos(phi)   ,    -np.cos(psi)*np.sin(theta)],<br>    [-np.sin(psi)*np.cos(theta)*np.cos(phi)-np.cos(psi)*np.sin(phi), -np.sin(psi)*np.cos(theta)*np.sin(phi)+np.cos(psi)*np.cos(phi) ,   np.sin(psi)*np.sin(theta) ],<br>    [np.sin(theta)*np.cos(phi)                               , np.sin(theta)*np.sin(phi)                                ,              np.cos(theta)]])<br><br>    R = R.T<br><br>    kx = np.arange(0, dims[0])-Xcenter<br>    ky = np.arange(0, dims[1])-Ycenter<br>    kz = np.arange(0, dims[2])-Zcenter<br><br>    # construct interpolator function that does the actual computation<br>    interpolator = RegularGridInterpolator((kx, ky, kz), modelK, bounds_error=False, fill_value=0)<br><br>    # build coordinates of the slice we want to calculate<br>    kx_slice, ky_slice, kz_slice = np.meshgrid((np.arange(0, dims[0])-Xcenter), (np.arange(0, dims[1])-Ycenter), 0)<br><br>    # rotate coordinates<br>    rotKCoords = np.zeros([3, np.size(kx_slice)])<br>    rotKCoords[0, :] = np.reshape(kx_slice, [1, np.size(kx_slice)])<br>    rotKCoords[1, :] = np.reshape(ky_slice, [1, np.size(ky_slice)])<br>    rotKCoords[2, :] = np.reshape(kz_slice, [1, np.size(kz_slice)])<br>    rotKCoords = np.dot(R, rotKCoords)<br><br>    # calculate projection<br>    projection = interpolator(rotKCoords.T)<br>    projection = np.reshape(projection, [dims[0], dims[1]], order='F')<br><br>    return np.real(ifftn_fftshift(projection))<br><br><font color="orange">def </font>getProjectionInterpolator(modelK):<br>    """<br>    * generateKspaceIndices *<br><br>    Maps the radial coordinate indices in the matrix obj<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright 2015-2016. All rights reserved.<br><br><br>    :param obj: Matrix of size to be mapped<br>    :return: 3D indices for each voxel in the volume<br>    """<br><br>    # get dimensions<br>    dims = np.shape(modelK)<br>    Xcenter = round(dims[0]//2)<br>    Ycenter = round(dims[1]//2)<br>    Zcenter = round(dims[2]//2)<br><br>    kx = np.arange(0, dims[0])-Xcenter<br>    ky = np.arange(0, dims[1])-Ycenter<br>    kz = np.arange(0, dims[2])-Zcenter<br><br>    # construct interpolator function that does the actual computation<br>    return RegularGridInterpolator((kx, ky, kz), modelK, bounds_error=False, fill_value=0)<br><br><font color="orange">def </font>calculateProjection_interp_fromInterpolator(interpolator, phi, theta, psi, dims):<br>    """<br>    * calculateProjection_interp_fromInterpolator *<br><br>    Calculate a projection from precomputed interpolator object<br><br>    :param interpolator: RegularGridInterpolator object from scipy.<br>    :param phi: euler angle 1<br>    :param theta: euler angle 2<br>    :param psi: euler angle 3<br>    :param dims: dimensions of the object<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright 2015-2016. All rights reserved.<br>    """<br><br>    # convert to radians<br>    phi *= PI/180<br>    theta *= PI/180<br>    psi *= PI/180<br><br>    Xcenter = round(dims[0]//2)<br>    Ycenter = round(dims[1]//2)<br>    Zcenter = round(dims[2]//2)<br><br>    # construct rotation matrix<br>    R = np.array([[np.cos(psi)*np.cos(theta)*np.cos(phi)-np.sin(psi)*np.sin(phi) , np.cos(psi)*np.cos(theta)*np.sin(phi)+np.sin(psi)*np.cos(phi)   ,    -np.cos(psi)*np.sin(theta)],<br>    [-np.sin(psi)*np.cos(theta)*np.cos(phi)-np.cos(psi)*np.sin(phi), -np.sin(psi)*np.cos(theta)*np.sin(phi)+np.cos(psi)*np.cos(phi) ,   np.sin(psi)*np.sin(theta) ],<br>    [np.sin(theta)*np.cos(phi)                               , np.sin(theta)*np.sin(phi)                                ,              np.cos(theta)]])<br><br>    R = R.T<br><br>    # build coordinates of the slice we want to calculate<br>    kx_slice, ky_slice, kz_slice = np.meshgrid((np.arange(0, dims[0])-Xcenter), (np.arange(0, dims[1])-Ycenter), 0)<br><br>    # rotate coordinates<br>    rotKCoords = np.zeros([3, np.size(kx_slice)])<br>    rotKCoords[0, :] = np.reshape(kx_slice, [1, np.size(kx_slice)])<br>    rotKCoords[1, :] = np.reshape(ky_slice, [1, np.size(ky_slice)])<br>    rotKCoords[2, :] = np.reshape(kz_slice, [1, np.size(kz_slice)])<br>    rotKCoords = np.dot(R, rotKCoords)<br><br>    # calculate projection<br>    projection = interpolator(rotKCoords.T)<br>    projection = np.reshape(projection, [dims[0], dims[1]], order='F')<br><br>    return np.real(ifftn_fftshift(projection))<br><br><br><font color="orange">def </font>calculateProjection_DFT(model, phi, theta, psi, out_dimx, out_dimy):<br>    """<br>    * calculateProjection_interp *<br><br>    Calculate a projection of a 3D volume using the Discrete Fourier Transform (DFT)<br><br>    :param model: numpy array holding the model<br>    :param phi: euler angle 1<br>    :param theta: euler angle 2<br>    :param psi: euler angle 3<br>    :param out_dimx: output projection size in x<br>    :param out_dimy: output projection size in y<br>    :return: projection<br>    """<br><br>    # get dimensions<br>    dims = np.shape(model)<br>    Xcenter = round(dims[0]//2)<br>    Ycenter = round(dims[1]//2)<br>    Zcenter = round(dims[2]//2)<br><br>    KXcenter = round(out_dimx//2)<br>    KYcenter = round(out_dimy//2)<br><br>    # convert to radians<br>    phi *= PI/180<br>    theta *= PI/180<br>    psi *= PI/180<br><br>    R = np.array([[np.cos(psi)*np.cos(theta)*np.cos(phi)-np.sin(psi)*np.sin(phi) , np.cos(psi)*np.cos(theta)*np.sin(phi)+np.sin(psi)*np.cos(phi)   ,    -np.cos(psi)*np.sin(theta)],<br>    [-np.sin(psi)*np.cos(theta)*np.cos(phi)-np.cos(psi)*np.sin(phi), -np.sin(psi)*np.cos(theta)*np.sin(phi)+np.cos(psi)*np.cos(phi) ,   np.sin(psi)*np.sin(theta) ],<br>    [np.sin(theta)*np.cos(phi)                               , np.sin(theta)*np.sin(phi)                                ,              np.cos(theta)]])<br><br>    R = R.T<br><br>    # build coordinates of 3D FFT<br><br>    X = np.arange(0, dims[0])-Xcenter<br>    Y = np.arange(0, dims[1])-Ycenter<br>    Z = np.arange(0, dims[2])-Zcenter<br>    X, Y, Z = np.meshgrid(X,Y,Z)<br>    Y = Y.astype(float)<br>    X = X.astype(float)<br>    Z = Z.astype(float)<br><br>    KX = np.arange(0, out_dimx)-KXcenter<br>    KY = np.arange(0, out_dimy)-KYcenter<br>    KY, KX, KZ = np.meshgrid(KY, KX, 0)<br>    KY = KY.astype(float)<br>    KX = KX.astype(float)<br>    KZ = KZ.astype(float)<br><br>    # build coordinates of the slice we want to calculate<br>    # kx_slice, ky_slice, kz_slice = np.meshgrid((np.arange(0, dims[0])-Xcenter), (np.arange(0, dims[1])-Ycenter), 0)<br><br>    # rotate coordinates<br>    rotKCoords = np.zeros([3, np.size(KX)])<br>    rotKCoords[0, :] = np.reshape(KX, [1, np.size(KX)])<br>    rotKCoords[1, :] = np.reshape(KY, [1, np.size(KY)])<br>    rotKCoords[2, :] = np.reshape(KZ, [1, np.size(KZ)])<br>    rotKCoords = np.dot(R, rotKCoords)<br><br>    rotKX = rotKCoords[0, :]<br>    rotKY = rotKCoords[1, :]<br>    rotKZ = rotKCoords[2, :]<br><br>    projection = np.zeros(out_dimx*out_dimy,dtype=complex)<br>    ind = np.where(model!=0) # only consider nonzero indices for speed<br>    mo<font color="orange">del </font>= model[ind]<br>    X = X[ind]<br>    Y = Y[ind]<br>    Z = Z[ind]<br>    <font color="orange">for </font>i in range(np.size(projection)): # compute DFT<br>        projection[i] = np.sum( mo<font color="orange">del </font>* np.exp( -2*PI*1j * \<br>                          ( rotKX[i]*X/out_dimx + rotKY[i]*Y/out_dimy + rotKZ[i]*Z/out_dimx ) ) )<br>    projection = np.reshape(projection, (out_dimx, out_dimy), order='F')<br><br>    # return np.real(pyfftw.interfaces.numpy_fft.fftshift(pyfftw.interfaces.numpy_fft.ifftn(pyfftw.interfaces.numpy_fft.ifftshift(projection))))<br>    return np.real(ifftn_fftshift(projection))<br><br><br><font color="orange">def </font>generateKspaceIndices(obj):<br>    """<br>    * generateKspaceIndices *<br><br>    Maps the radial coordinate indices in the matrix obj<br><br>    Author: Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright 2015-2016. All rights reserved.<br><br><br>    :param obj: Matrix of size to be mapped<br>    :return: 3D indices for each voxel in the volume<br>    """<br><br>    dims = np.shape(obj)<br>    <font color="orange">if </font>len(dims) < 3:<br>        dims = dims + (0,)<br><br>    <font color="orange">if </font>dims[0] % 2 == 0:<br>        ncK0 = dims[0]/2<br>        vec0 = np.arange(-ncK0, ncK0, 1)/ncK0<br>    <font color="orange">el<font color="orange">if </font></font>dims[0] == 1:<br>        vec0 = 0<br>        ncK0 = 1<br><br>    else:<br>        ncK0 = ((dims[0]+1)/2)-1<br>        vec0 = np.arange(-ncK0, ncK0+1)/ncK0<br><br><br>    <font color="orange">if </font>dims[1] % 2 == 0:<br>        ncK1 = dims[1]/2<br>        vec1 = np.arange(-ncK1, ncK1, 1)/ncK1<br>    <font color="orange">el<font color="orange">if </font></font>dims[1] == 1:<br>        vec1 = 0<br>        ncK1 = 1<br><br>    else:<br>        ncK1 = ((dims[1]+1)/2)-1<br>        vec1 = np.arange(-ncK1, ncK1+1)/ncK1<br><br><br>    <font color="orange">if </font>dims[2] % 2 == 0:<br>        ncK2 = dims[2]/2<br>        vec2 = np.arange(-ncK2, ncK2, 1)/ncK2<br>    <font color="orange">el<font color="orange">if </font></font>dims[2] == 1:<br>        vec2 = 0<br>        ncK2 = 1<br><br>    else:<br>        ncK2 = ((dims[2]+1)/2)-1<br>        vec2 = np.arange(-ncK2, ncK2+1)/ncK2<br><br>    kx, ky, kz = np.meshgrid(vec1,vec0,vec2)<br>    Kindices = np.sqrt(kx**2 + ky**2 + kz**2)<br>    return Kindices<br><br><font color="orange">def </font>pointToPlaneDistance(points, norm_vec):<br>    """<br>    * pointToPlaneDistance *<br><br>    compute distance from point to a plane with normal vector norm_vec passing through origin<br><br>    :param points: num_points x 3 array of (x,y,z) points<br>    :param norm_vec: (a,b,c) normal vector defining the plane ax + by + cz = 0<br>    :return: numpy array containing distance to plane<br><br>    Author: Yongsoo Yang<br>    Transcribed from MATLAB by Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright 2015-2016. All rights reserved.<br>    """<br>    <font color="orange">from </font>numpy.linalg <font color="orange">import </font>norm<br>    norm_vec = norm_vec / norm(norm_vec)<br>    <font color="orange">if </font>np.ndim(points)>1:<br>        distances = np.abs(np.sum(points*norm_vec,axis=1))<br>        return distances<br>    return np.abs(np.dot(points,norm_vec))<br><br><font color="orange">def </font>pointToPlaneClosest(points, norm_vec, distances):<br>    """<br>    * pointToPlaneClosest *<br><br>    compute the closest point in the plane defined by normal vector norm_vec to each<br>    point in points<br><br>    :param points: num_points x 3 array of (x,y,z) points<br>    :param norm_vec: (a,b,c) normal vector defining the plane ax + by + cz = 0<br>    :param distances: magnitude of distance to plane (see pointToPlaneDistance)<br>    :return:  numpy array containing the coordinates of the closest points<br><br>    Author: Yongsoo Yang<br>    Transcribed from MATLAB codes by Alan (AJ) Pryor, Jr.<br>    Jianwei (John) Miao Coherent Imaging Group<br>    University of California, Los Angeles<br>    Copyright 2015-2016. All rights reserved.<br>    """<br>    <font color="orange">if </font>np.ndim(points)>1: # use NumPy broadcasting for speed<br>        closest_points = points + ( (distances - np.sum(points * norm_vec)) * np.reshape(norm_vec,(3,1)) / np.dot(norm_vec,norm_vec) ).T<br>        return closest_points<br>    return points + (distances- np.dot(points, norm_vec)) * norm_vec<br><br></code></body>
    </html>